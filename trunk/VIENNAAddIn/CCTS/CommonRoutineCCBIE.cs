using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;
using EA;
using GIEM.Utils;
using GIEM.Exceptions;

namespace GIEM.CCTS
{
    class CommonRoutineCCBIE : GeneratorCallBackInterface
    {
        #region Variable
        //we use "internal" because it should can be accessed through its instance
        internal Repository repository;
        internal String scope;
        internal Boolean annotate;
        internal bool withGUI;
        //internal bool blnUseAlias = false;
        internal GeneratorCallBackInterface caller;
        internal bool blnNillable = false;
        internal string typeLibrary = "";
        internal bool blnUseAlias;
        internal bool blnIncludeLinkedSchema;

        private enum typeLibraryEnum { CCLibrary, BIELibrary};
        private enum typeElementEnum { ELEMENT, ATTRIBUTE, CONNECTOR };

        //This ArrayList holds a List of all auxilliary schmeas
        //that had to be created for this schema to be valid
        internal System.Collections.ArrayList alreadyCreatedSchemas = new ArrayList();

        //This arraylist hold a list of auxilliary schema that generated by BusinessLibraryGenerator
        internal ArrayList alreadyCreatedSchemasBLGen;

        //if generate from anyLevel, its value will be true, otherwise if generated from specific package it will be false;
        internal bool isAnyLevelGeneration = false;

        //The path where the schema(s) should be saved
        internal String path = "";
        private String targetNameSpacePrefix = "";

        //These variables are used to make a distinction between namespaces of the same type
         int countQDTImports = 0;
         int countUDTImports = 0;
         int countENUMImports = 0;
         int countBIEImports = 0;

        #endregion

        #region GeneratorCallBackInterface implementation
        /// <sUMM2ary>
        /// Append an error message to the status box
        /// </sUMM2ary>
        /// <param name="msg"></param>
        private void appendErrorMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("error", msg, this.getPackageName());
            }
            //else
            //{
            //    if (this.withGUI)
            //    {
            //        this.statusTextBox.Text += "ERROR: (Package: " + packageName + ") " + msg + "\n\n";
            //    }
            //}
        }

        /// <sUMM2ary>
        /// Returns the name of the current package
        /// </sUMM2ary>
        /// <returns></returns>
        private String getPackageName()
        {
            return this.repository.GetPackageByID(Int32.Parse(this.scope)).Name.ToString();
        }

        /// <sUMM2ary>
        /// Show a info message in the status box
        /// </sUMM2ary>
        /// <param name="msg"></param>
        private void appendInfoMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("info", msg, this.getPackageName());
            }
            //else
            //{
            //    if (this.withGUI)
            //    {
            //        this.statusTextBox.Text += "INFO: (Package: " + packageName + ") " + msg + "\n\n";
            //    }
            ////}
        }
        /// <sUMM2ary>
        /// Show a warn message in the status box
        /// </sUMM2ary>
        /// <param name="msg"></param>
        private void appendWarnMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("warn", msg, this.getPackageName());
            }
            //else
            //{
            //    if (this.withGUI)
            //        this.statusTextBox.Text += "WARN: (Package: " + packageName + ") " + msg + "\n\n";
            //}
        }


        /// <sUMM2ary>
        /// Is called from extern to append a message to this GUI
        /// </sUMM2ary>
        /// <param name="type"></param>
        /// <param name="message"></param>
        public void appendMessage(String type, String message, String packageName)
        {
            if (type == "info")
                this.appendInfoMessage(message, packageName);
            else if (type == "warn")
                this.appendWarnMessage(message, packageName);
            else if (type == "error")
                this.appendErrorMessage(message, packageName);

        }

        /// <sUMM2ary>
        /// Performs a step with the progress bar
        /// </sUMM2ary>
        public void performProgressStep()
        {
            //if (this.withGUI)
            //{
            //    this.progressBar1.PerformStep();
            //}
            //else
            //{
                //Is there a caller for this class?
                if (caller != null)
                    caller.performProgressStep();
            //}
        }
        #endregion

        #region Constructor

        /// <sUMM2ary>
        /// Constructor for any level schema generation CC/BIELibrary
        /// </sUMM2ary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        public CommonRoutineCCBIE(EA.Repository repository, String scope, bool annotate, bool blnIncludeLinkedSchema, 
            bool blnAlias, bool blnNillable, string path, ArrayList alreadyCreatedSchemaBLGen, 
            GeneratorCallBackInterface caller, string typeLibrary, bool isAnyLevelGeneration)
        {
            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.blnUseAlias = blnAlias;
            this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
            this.blnNillable = blnNillable;

            this.path = path;
            //With GUI
            this.withGUI = false;
            //InitializeComponent();
            //this.setActivePackageLabel();
            this.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
            this.isAnyLevelGeneration = true;
            this.typeLibrary = typeLibrary;
            
            if (typeLibrary == typeLibraryEnum.CCLibrary.ToString())
                this.targetNameSpacePrefix = "cc";
            else
                this.targetNameSpacePrefix = "bie";
        }

        /// <sUMM2ary>
        /// Constructor for single CC generation
        /// </sUMM2ary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        public CommonRoutineCCBIE(EA.Repository repository, String scope, bool annotate, GeneratorCallBackInterface caller, string typeLibrary)
        {
            //Set the debug mode
            //DEBUG = RepositoryUtils.DEBUG;

            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.caller = caller;
            
            //With GUI
            this.withGUI = true;
            //InitializeComponent();
            //this.setActivePackageLabel();
            this.isAnyLevelGeneration = false;
            this.typeLibrary = typeLibrary;

            if (typeLibrary == typeLibraryEnum.CCLibrary.ToString())
                this.targetNameSpacePrefix = "cc";
            else
                this.targetNameSpacePrefix = "bie";
        }


        public CommonRoutineCCBIE()
        {
            //do nothing
        }
        public CommonRoutineCCBIE(EA.Repository repository, String scope, bool annotate, bool blnLinkedSchema, bool blnAlias,
            bool blnNillable, String path, GeneratorCallBackInterface caller)
        {
            this.caller = caller;
            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
            this.blnUseAlias = blnAlias;
            this.blnNillable = blnNillable;

            this.path = path;

            if (typeLibrary == typeLibraryEnum.CCLibrary.ToString())
                this.targetNameSpacePrefix = "cc";
            else
                this.targetNameSpacePrefix = "bie";
        }
        #endregion

        #region Method
        public  string getStereotype(string elementType)
        {
            if (this.typeLibrary == typeLibraryEnum.CCLibrary.ToString())
            {
                if (elementType == typeElementEnum.ELEMENT.ToString())
                    return CCTS_Types.ACC.ToString();
                else if (elementType == typeElementEnum.CONNECTOR.ToString()) 
                    return CCTS_Types.ASCC.ToString(); 
                else if (elementType == typeElementEnum.ATTRIBUTE.ToString()) 
                    return CCTS_Types.BCC.ToString(); 
            }
            else if (this.typeLibrary == typeLibraryEnum.BIELibrary.ToString())
            {
                if (elementType == typeElementEnum.ELEMENT.ToString()) 
                    return CCTS_Types.ABIE.ToString(); 
                else if (elementType == typeElementEnum.CONNECTOR.ToString()) 
                    return CCTS_Types.ASBIE.ToString(); 
                else if (elementType == typeElementEnum.ATTRIBUTE.ToString()) 
                    return CCTS_Types.BBIE.ToString(); 
            }

            return "";
        }

        /// <sUMM2ary>
        /// Creates a Schema Element for the passed EA.Element
        /// </sUMM2ary>
        /// <param name="e"></param>
        /// <returns></returns>
        internal XmlSchemaComplexType getSchemaElement(EA.Element e, XmlSchema schema)
        {
            

            //Create an new ComplexType for the passed ABIE
            XmlSchemaComplexType complexType = new XmlSchemaComplexType();
            complexType.Name = XMLTools.getXMLName(e.Name) + "Type";
            XmlSchemaSequence sequence = new XmlSchemaSequence();

            if (!XMLTools.isElementAlreadyIncludedInSchema(schema, complexType.Name))
            {

                //Get the annotation
                if (this.annotate)
                    complexType.Annotation = getABIEAnnotation(e);

                #region get attribute

                ArrayList tempPostion = new ArrayList();
                ArrayList tempNoPostion = new ArrayList();

                foreach (EA.Attribute attr in e.Attributes)
                {
                    SearchAttributeForPositionTaggedValue(attr, tempPostion, tempNoPostion);
                }

                #endregion

                #region get aggregation

                //Now check, whether there are any ASBIEs
                foreach (EA.Connector con in e.Connectors)
                {
                    if (con.Type == EA_Element.Aggregation.ToString() && con.Stereotype.ToString() == getStereotype(typeElementEnum.CONNECTOR.ToString())//CCTS_Types.ASCC.ToString()
                        && con.SupplierID == e.ElementID)
                    {
                        //Elements within the BIE library may have connectors which lead to DOCLibraries
                        //(because BIEs are used within DOCLibraries)
                        //Ignore such connectors                    
                        EA.ConnectorEnd clientEnd = con.ClientEnd;
                        EA.Element client = this.repository.GetElementByID(con.ClientID);
                        EA.Element supplier = this.repository.GetElementByID(con.SupplierID);

                        //Is the connection type an Aggregation or a Composition?
                        //A composition == 2
                        bool isComposition = false;
                        if (con.SupplierEnd.Aggregation == 2)
                        {
                            isComposition = true;
                        }
                        String elementName = "";

                        //If a role name is specified, we take the name of the
                        //role and create a new element from it (if it does not already exist)
                        //If a role name is specified, the name is
                        //Supplier.Name + Role.Name + Client.Name
                        if (clientEnd.Role != "")
                        {
                            elementName = XMLTools.getXMLName(clientEnd.Role + client.Name);
                        }
                        else
                        {
                            //If no role name is specified, the name is
                            //Supplier.Name + Client.Name
                            elementName = XMLTools.getXMLName(client.Name);
                        }


                        if (isInSamePackage(client))
                        {
                            //if (!isComposition) {
                            //    if (!XMLTools.isElementAlreadyIncludedInSchema(schema, elementName)) {
                            //        //We need to create a new element
                            //        XmlSchemaElement xel = new XmlSchemaElement();
                            //        xel.Name = elementName;
                            //        xel.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //        schema.Items.Add(xel);
                            //    }
                            //}

                            //Now add a reference to this element to the sequence
                            XmlSchemaElement elemRef = new XmlSchemaElement();

                            //Annotate?
                            if (this.annotate)
                                elemRef.Annotation = getASBIEAnnotation(con);

                            ////Set the cardinality of the element
                            setASBIECardinality(elemRef, clientEnd.Cardinality);

                            //If the association is a composition we have to declare the ASBIE
                            //locally

                            //aggregation or composition is treated the same way - for quick fix
                            //if (isComposition) {
                            elemRef.Name = elementName;
                            elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //}
                            //else {
                            //    elemRef.RefName = new XmlQualifiedName(elementName, XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //}

                            #region search for 'position' tagged value
                            //aggregation or composition is treated the same way - for quick fix
                            //if (isComposition)
                            SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

                            #endregion

                        }
                        //Not from this BIELibrary
                        else
                        {

                            //We only import other elements if they are located in a BIELibrary or CCLibrary
                            EA.Package p = this.repository.GetPackageByID(client.PackageID);
                            if (p.Element.Stereotype.Equals(CCTS_Types.BIELibrary.ToString()) || p.Element.Stereotype.Equals(CCTS_Types.CCLibrary.ToString()))
                            {

                                XmlQualifiedName qName = createAndImportAuxilliarySchema(client, schema);
                                XmlSchemaElement elemRef = new XmlSchemaElement();
                                //Annotate?
                                if (this.annotate)
                                    elemRef.Annotation = getASBIEAnnotation(con);

                                ////Set the cardinality of the element
                                setASBIECardinality(elemRef, clientEnd.Cardinality);

                                //If the association is a composition we have to declare the ASBIE
                                //locally
                                //aggregation or composition is treated the same way - for quick fix
                                //if (isComposition) {
                                elemRef.Name = elementName;
                                elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(client.PackageID)));
                                //}
                                //else {
                                //    elemRef.RefName = qName;
                                //}

                                #region search for 'position' tagged value
                                //aggregation or composition is treated the same way - for quick fix
                                //if (isComposition)
                                SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

                                #endregion

                            }
                        }
                    }
                }

                #endregion

                #region Sort the BBIE and ASBIE
                //sort connector, then insert it into sequence
                SortByPosition comparerPosition = new SortByPosition();
                SortByName comparerName = new SortByName();

                tempPostion.Sort(comparerPosition);
                tempNoPostion.Sort(comparerName);

                //sort the element with "position" tagged value
                foreach (object obj in tempPostion)
                {
                    if (((ArrayList)obj)[2].ToString() == "Attribute")
                    {
                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                        if (attribute.Stereotype.Equals(getStereotype(typeElementEnum.ATTRIBUTE.ToString()))) //CCTS_Types.BCC.ToString()))
                        {
                            XmlSchemaElement attrElem = new XmlSchemaElement();
                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
                            //Set the type
                            setBBIEType(attrElem, attribute, schema, e);
                            //Set the cardinality
                            setBBIECardinality(attrElem, attribute);
                            //Get the annotation
                            if (this.annotate)
                                attrElem.Annotation = getBBIEAnnotation(attribute);
                            //check for lower cardinality, if lower bound = 0, add nillable attribute
                            if (getCaller().GetType() == typeof(DOCGenerator))
                            {
                                DOCGenerator theCaller = (DOCGenerator)getCaller();
                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }
                            else
                            {
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }

                            //Add the element to the sequence
                            sequence.Items.Add(attrElem);
                        }
                    }
                    else if (((ArrayList)obj)[2].ToString() == "Connector")
                    {
                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                        sequence.Items.Add(schemaElement);
                    }

                }

                //sort the element alphabetically
                foreach (object obj in tempNoPostion)
                {
                    if (((ArrayList)obj)[2].ToString() == "Attribute")
                    {
                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                        if (attribute.Stereotype.Equals(getStereotype(typeElementEnum.ATTRIBUTE.ToString())))//CCTS_Types.BCC.ToString()))
                        {
                            XmlSchemaElement attrElem = new XmlSchemaElement();
                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
                            //Set the type
                            setBBIEType(attrElem, attribute, schema, e);
                            //Set the cardinality
                            setBBIECardinality(attrElem, attribute);
                            //Get the annotation
                            if (this.annotate)
                                attrElem.Annotation = getBBIEAnnotation(attribute);

                            //check for lower cardinality, if lower bound = 0, add nillable attribute
                            if (getCaller().GetType() == typeof(DOCGenerator))
                            {
                                DOCGenerator theCaller = (DOCGenerator)getCaller();
                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }
                            else
                            {
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }

                            //Add the element to the sequence
                            sequence.Items.Add(attrElem);
                        }
                    }
                    else if (((ArrayList)obj)[2].ToString() == "Connector")
                    {
                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                        sequence.Items.Add(schemaElement);
                    }
                }

                //generate warning if there is a mix sort, alphabetically and sequence
                if ((tempPostion.Count > 0) && (tempNoPostion.Count > 0))
                    this.appendWarnMessage("There is a mix of sequence and alphabetic sorting of attributes (BBIEs) and aggregations (ASBIEs)", this.getPackageName());

                #endregion
            }

            complexType.Particle = sequence;

            return complexType;

        }

        /// <sUMM2ary>
        /// Search Connector with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the element with type XMLSchemaElement
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </sUMM2ary>
        /// <returns></returns>
        private  void SearchConnectorForPositionTaggedValue(EA.Collection col, ArrayList tempPosition, ArrayList tempNoPosition, XmlSchemaElement elemRef)
        {
            bool isError = false;
            bool isPositionExist = false;


            //search for attribute's tagged value 'position'
            foreach (EA.ConnectorTag tagval in col)
            {
                //if "position" tagged value exist and has value
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != ""))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(elemRef);
                        temp.Add("Connector");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(elemRef.Name);
                temp.Add(elemRef);
                temp.Add("Connector");

                tempNoPosition.Add(temp);
            }
        }

        /// <sUMM2ary>
        /// Search Attribute with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the attribute with type EA.Attribute
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </sUMM2ary>
        /// <returns></returns>
        //private  void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempAttr, ArrayList tempAttrWithPosition)
        private  void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempPosition, ArrayList tempNoPosition)
        {
            bool isError = false;
            bool isPositionExist = false;

            foreach (EA.AttributeTag tagval in attr.TaggedValues)
            {
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != null))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                        break;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(attr);
                        temp.Add("Attribute");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(attr.Name);
                temp.Add(attr);
                temp.Add("Attribute");

                tempNoPosition.Add(temp);
            }
        }


        private  XmlQualifiedName createAndImportAuxilliarySchema(EA.Element e, XmlSchema schema)
        {
            //Get the package of origin of the element
            EA.Package p = this.repository.GetPackageByID(e.PackageID);
            String pName = p.Name;
            String s = "";

            //if the generation is from any level generation
            if (isAnyLevelGeneration)
            {
                String sBLGen = "";
                //is the schema already included in global array?
                if ((s = isSchemaAlreadyIncluded(p.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(p.Name)) != "")
                {
                    #region for any level package generation, to check if there was previously generated schema
                    ////We need to add an import statement for the newly generated schema
                    ////to the original schema
                    ////if (different package than previously generated) and !(already included)

                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();

                    //String schemaPath = "";
                    String schemaName = "";
                    //schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository);
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
                    //String filename = path + schemaPath + schemaName;


                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnUseAlias);//CC_Utils.blnUseAlias);

                    determineImportOrInclude(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;

                    //add the schema to local alreadyCreatedSchema
                    this.alreadyCreatedSchemas.Add(aux);
                    #endregion
                }
            }

            //Is this schema already included?
            if ((s = isSchemaAlreadyIncluded(p.Name)) == "")
            {
                if (!this.blnIncludeLinkedSchema)//CC_Utils.blnLinkedSchema)
                {
                    #region Include linked schema unchecked - for particular generation only
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();
                    this.alreadyCreatedSchemas.Add(aux);

                    String schemaName = "";
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));

                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnUseAlias);

                    addImport(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;
                    #endregion
                }
                else
                {
                    #region Include linked schema checked

                    System.Collections.ICollection result = null;

                    if (p.Element.Stereotype == CCTS_Types.BIELibrary.ToString())
                    {
                        result = new BIEGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(p);
                    }
                    else if (p.Element.Stereotype == CCTS_Types.CCLibrary.ToString())
                    {
                        result = new CCGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema, 
                            this.blnUseAlias, this.blnNillable ,this.path, getCaller()).generateSchema(p);
                    }
                    //Create an Auxilliary schema and store it in the collection - later we have to
                    //add it to the main schema collection
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    if (this.typeLibrary == typeLibraryEnum.BIELibrary.ToString())
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    else
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "cc" + ++countBIEImports);

                    aux.PackageOfOrigin = p.Name.ToString();
                    aux.Schemas = result;
                    
                    this.alreadyCreatedSchemas.Add(aux);

                    if (isAnyLevelGeneration)
                        this.alreadyCreatedSchemasBLGen.Add(aux);


                    String schemaPath = "";
                    String schemaName = "";
                    schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository, this.blnUseAlias);
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
                    String filename = path + schemaPath + schemaName;

                    //Write the schema(s)
                    foreach (XmlSchema schema1 in result)
                    {
                        //Create the path
                        System.IO.Directory.CreateDirectory(path + schemaPath);
                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                        schema1.Write(outputStream);
                        outputStream.Close();
                    }

                    //We need to add an import statement for the newly generated schema
                    //to the original schema
                    String importPath = XMLTools.getImportPathForSchema(p, repository, schemaName, scope, this.blnUseAlias);

                    //check whether it's "include" or "import"
                    determineImportOrInclude(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;

                    #endregion
                }
            }

            return new XmlQualifiedName(e.Name + "Type", s);

        }

        private void determineImportOrInclude(XmlSchema schema, String schemaLocation, String namespace_)
        {
            if (schema.TargetNamespace == namespace_)
                addInclude(schema, schemaLocation, namespace_);
            else
                addImport(schema, schemaLocation, namespace_);
        }

        /// <sUMM2ary>
        /// Return the Annotation for a given ASBIE element
        /// </sUMM2ary>
        /// <param name="name"></param>
        /// <returns></returns>
        internal XmlSchemaAnnotation getASBIEAnnotation(EA.Connector con)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();

            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*Cardinality", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*PropertyTerm", 
                "*PropertyQualifierTerm", 
                "*AssociatedObjectClassTerm", 
                "*AssociatedObjectClassQualifierTerm", 
                "*AssociationType", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm",     
                "*Example",
                "*RepresentationLayout" //,
                //"*Notes"
            };

            String[] values = { XMLTools.getConnectorTVValue(CCTS_TV.UniqueID,con), 
                getStereotype(typeElementEnum.CONNECTOR.ToString()), //"ASCC", 
                XMLTools.getConnectorTVValue(CCTS_TV.DictionaryEntryName,con), 
                XMLTools.getConnectorTVValue(CCTS_TV.Version,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.Definition,con), 
                getASBIECardinality(con.ClientEnd), 
                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassQualifierTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.PropertyTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.PropertyQualifierTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassQualifierTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.AssociationType,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.GeopoliticalOrRegionContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.OfficialConstraintContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.ProductContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.IndustryContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.SupportingRoleContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.SystemCapabilitiesContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.UsageRule,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.Example,con),
                XMLTools.getConnectorTVValue(CCTS_TV.RepresentationLayout,con)//,
                //con.Notes
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }


        /// <sUMM2ary>
        /// Return the ASBIE Cardinality
        /// </sUMM2ary>
        /// <param name="clientEnd"></param>
        /// <returns></returns>
        private  String getASBIECardinality(EA.ConnectorEnd clientEnd)
        {

            if (clientEnd.Cardinality == "")
                return "1";
            else
                return clientEnd.Cardinality;
        }


        /// <sUMM2ary>
        /// Sets the cardinality of the element according to the information in the 
        /// AggregateBusinessInformationEntity
        /// This proves to be a little bit more tricky than with the BCC because we
        /// receive only one String containing both, the upper and the lower bound
        /// </sUMM2ary>
        /// <param name="e1"></param>
        /// <param name="abie"></param>
        internal void setASBIECardinality(XmlSchemaElement e1, String c)
        {

            String lower = "";
            String upper = "";
            try
            {
                //Try to split up the String
                String cardinality = c;
                lower = cardinality.Substring(0, 1);
                upper = cardinality.Substring(3);
            }
            catch { }

            try
            {
                //Try to set the lower
                int i = Int32.Parse(lower);
                e1.MinOccurs = i;
            }
            catch { }

            try
            {
                //Try to set the upper
                if (upper == "*")
                    e1.MaxOccursString = "unbounded";
                else
                {
                    int i = Int32.Parse(upper);
                    if (i != 1)
                        e1.MaxOccurs = i;
                }
            }
            catch { }

        }


        /// <sUMM2ary>
        /// Return the Annotation for a given ABIE element
        /// </sUMM2ary>
        /// <param name="name"></param>
        /// <returns></returns>
        private  XmlSchemaAnnotation getABIEAnnotation(EA.Element abie)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();
            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm", 
                "*Example",
                "*RepresentationLayout"//,
                //"*Notes"
            };

            //Get ObjectClassTerm & ObjectClassQualifierTerm
            string[] objClassTerm = GetObjectClassTerm(abie);

            String[] values = { XMLTools.getElementTVValue(CCTS_TV.UniqueID, abie), 
                getStereotype(typeElementEnum.ELEMENT.ToString()), //"ACC", 
                XMLTools.getElementTVValue(CCTS_TV.DictionaryEntryName, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Version, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Definition, abie),
                objClassTerm[1] != null ? objClassTerm[1] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassTerm, abie), 
                objClassTerm[0] != null ? objClassTerm[0] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassQualifierTerm, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, abie),                  
                XMLTools.getElementTVValue(CCTS_TV.OfficialConstraintContextValue, abie),                
                XMLTools.getElementTVValue(CCTS_TV.ProductContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.IndustryContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessRoleContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.SupportingRoleContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.SystemCapabilitiesContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.UsageRule, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessTerm, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Example, abie),
                XMLTools.getElementTVValue(CCTS_TV.RepresentationLayout, abie)//,
                //abie.Notes
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }

        private  string[] GetObjectClassTerm(Element abie)
        {
            string[] objClassTerm = new string[2];
            foreach (EA.TaggedValue tg in abie.TaggedValues)
            {
                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
                {
                    string dict = tg.Value;
                    string[] partsOfDEN = null;

                    //split the Dictionary Entry Name into three part
                    for (int i = 1; i < 4; i++)
                    {
                        partsOfDEN = dict.Split(".".ToCharArray(), i);
                    }

                    string[] splitFirstPart = null;
                    //split the first part of DEN
                    for (int i = 1; i < 3; i++)
                    {
                        splitFirstPart = partsOfDEN[0].Split("_".ToCharArray(), i);
                    }
                    if (splitFirstPart.GetUpperBound(0) == 1)  // "object class term qualifier" is exist
                    {
                        objClassTerm[0] = splitFirstPart[0]; //object class term qualifier
                        objClassTerm[1] = splitFirstPart[1]; //Object Class Term
                    }
                    else
                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term

                    break;
                }
            }
            return objClassTerm;
        }


        /// <sUMM2ary>
        /// Return the Annotation for a given BBIE element
        /// </sUMM2ary>
        /// <returns></returns>
        internal XmlSchemaAnnotation getBBIEAnnotation(EA.Attribute bcc)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();

            String card = bcc.LowerBound + ".." + bcc.UpperBound;
            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*Cardinality", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*PropertyTerm", 
                "*PropertyQualifierTerm", 
                "*PrimaryRepresentationTerm", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm", 
                "*Example",
                "*RepresentationLayout"//,
                //"*Notes"
            };

            //Get ObjectClassTerm & ObjectClassQualifierTerm
            string[] objClassTerm = GetObjectClassTermBBIE(bcc);

            String[] values = { XMLTools.getAttributeTVValue(CCTS_TV.UniqueID, bcc), 
                getStereotype(typeElementEnum.ATTRIBUTE.ToString()), //"BCC", 
                XMLTools.getAttributeTVValue(CCTS_TV.DictionaryEntryName, bcc), 
                XMLTools.getAttributeTVValue(CCTS_TV.Version, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.Definition, bcc), 
                card, 
                objClassTerm != null ? (objClassTerm[1] != null ? objClassTerm[1] : "") : "" ,//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassTerm, bbie), 
                objClassTerm != null ? (objClassTerm[0] != null ? objClassTerm[0] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassQualifierTerm, bbie), 
                objClassTerm != null ? (objClassTerm[3] != null ? objClassTerm[3] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyTerm, bbie), 
                objClassTerm != null ? (objClassTerm[2] != null ? objClassTerm[2] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyQualifierTerm, bbie),
                objClassTerm != null ? (objClassTerm[4] != null ? objClassTerm[4] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PrimaryRepresentationTerm, bbie),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.OfficialConstraintContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.ProductContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.IndustryContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.SupportingRoleContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.SystemCapabilitiesContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.UsageRule, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessTerm, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.Example, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.RepresentationLayout, bcc)//,
                //bbie.Notes
                
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }

        private  string[] GetObjectClassTermBBIE(EA.Attribute bbie)
        {
            string[] objClassTerm = new string[6];
            foreach (EA.AttributeTag tg in bbie.TaggedValues)
            {
                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
                {
                    string dict = tg.Value;
                    string[] partsOfDEN = null;

                    //split the Dictionary Entry Name into three part
                    for (int i = 1; i < 4; i++)
                    {
                        partsOfDEN = dict.Split(".".ToCharArray(), i);
                    }

                    if (partsOfDEN.GetUpperBound(0) != 2)  //if the DEN doesn't have correct parts. The correct DEN must have 3 parts.
                        return null;

                    //split first part of DEN
                    string[] splitFirstPart = null;
                    splitFirstPart = SplitDEN(partsOfDEN[0]);

                    if (splitFirstPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitFirstPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitFirstPart.GetUpperBound(0) - 1))
                                qualifier += splitFirstPart[a];
                            else
                                qualifier += splitFirstPart[a] + "_";
                        }
                        objClassTerm[0] = qualifier; //object class term qualifier
                        objClassTerm[1] = splitFirstPart[splitFirstPart.GetUpperBound(0)]; //Object Class Term
                    }
                    else
                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term


                    //split second part of DEN
                    string[] splitSecondPart = null;
                    splitSecondPart = SplitDEN(partsOfDEN[1]);

                    if (splitSecondPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitSecondPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitSecondPart.GetUpperBound(0) - 1))
                                qualifier += splitSecondPart[a];
                            else
                                qualifier += splitSecondPart[a] + "_";
                        }
                        objClassTerm[2] = qualifier; //property term qualifier
                        objClassTerm[3] = splitSecondPart[splitSecondPart.GetUpperBound(0)]; //Property Term
                    }
                    else
                        objClassTerm[2] = partsOfDEN[1]; //Object Class Term

                    //split third part of DEN
                    string[] splitThirdPart = null;
                    splitThirdPart = SplitDEN(partsOfDEN[2]);

                    if (splitThirdPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitThirdPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitThirdPart.GetUpperBound(0) - 1))
                                qualifier += splitThirdPart[a];
                            else
                                qualifier += splitThirdPart[a] + "_";
                        }
                        objClassTerm[4] = qualifier; //Associated Object Class Term Qualifier
                        objClassTerm[5] = splitThirdPart[splitThirdPart.GetUpperBound(0)]; //Associated Object Class Term
                    }
                    else
                        objClassTerm[4] = partsOfDEN[2]; //Representation Term


                    ////split the third part of DEN
                    //string[] splitThirdPart = null;
                    //for (int i = 1; i < 3; i++)
                    //{
                    //    splitThirdPart = partsOfDEN[2].Split("_".ToCharArray(), i);
                    //}
                    //if (splitThirdPart.GetUpperBound(0) == 1)  // "property term qualifier" is exist
                    //{
                    //    objClassTerm[2] = splitThirdPart[0]; //property term qualifier
                    //    objClassTerm[3] = splitThirdPart[1]; //Property Term
                    //}
                    //else
                    //    objClassTerm[2] = partsOfDEN[2]; //Property Term

                    ////Representation Term
                    //objClassTerm[4] = partsOfDEN[1]; // second part of DEN
                    break;
                }
            }
            return objClassTerm;
        }


        private  string[] SplitDEN(string dictEntryName)
        {
            string[] splitFirstPart = null;
            string temp = dictEntryName;
            int count = 1;
            //as long the string still contain "_", we split it.
            do
            {
                splitFirstPart = dictEntryName.Split("_".ToCharArray(), count); //split optional qualifier "_" from first part of ASBIE (target Name)
                temp = splitFirstPart[count - 1];
                count++;
            } while (temp.Contains("_"));

            return splitFirstPart;
        }


        /// <sUMM2ary>
        /// Sets the cardinality of the element according to the information in the 
        /// BasicBusinessInformationEntity
        /// </sUMM2ary>
        /// <param name="e1"></param>
        /// <param name="abie"></param>
        private  void setBBIECardinality(XmlSchemaElement e1, EA.Attribute bbie)
        {

            //Set Lower Bound            
            try
            {
                int lower = Int32.Parse(bbie.LowerBound);
                e1.MinOccurs = lower;
            }
            catch (Exception e) { }

            //Set Upper Bound
            try
            {
                if (bbie.UpperBound == "*")
                {
                    e1.MaxOccursString = "unbounded";
                }
                else
                {
                    int upper = Int32.Parse(bbie.UpperBound);
                    //We do not need to consider 1 as this is the default value
                    if (upper != 1)
                        e1.MaxOccurs = upper;
                }
            }
            catch (Exception e) { }
        }



        /// <sUMM2ary>
        /// Sets the type of the given bbie
        /// If the type refers to a cdt/qdt the method first checks,
        /// whether the relevant schema does already exist
        /// If not the schema is created and a reference via import statement
        /// is made
        /// </sUMM2ary>
        /// <param name="e"></param>
        /// <param name="bbie"></param>
        private  void setBBIEType(XmlSchemaElement e, EA.Attribute bbie, XmlSchema schema, EA.Element element)
        {
            //Kristina 7 Nov 07 - still not sure on this generation, currently it's only copied from BIELibrary
            try
            {

                String type = bbie.Type;
                int classifierID = bbie.ClassifierID;
                if (classifierID == 0)
                {
                    throw new Exception("Can't find classifier ID for <<" + getStereotype(typeElementEnum.ATTRIBUTE.ToString()) + ">>" + bbie.Name
                        + " of <<" + getStereotype(typeElementEnum.ELEMENT.ToString()) + ">>" + element.Name);
                }

                EA.Element classifierElement = this.repository.GetElementByID(classifierID);
                EA.Package classifierPackage = this.repository.GetPackageByID(classifierElement.PackageID);
                String stereotype = classifierPackage.Element.Stereotype;
                String s = "";

                //if the generation is from any level generation
                if (isAnyLevelGeneration)
                {
                    String sBLGen = "";
                    if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(classifierPackage.Name)) != "")
                    {
                        #region for any level package generation, to check if there was previously generated schema
                        ////We need to add an import statement for the newly generated schema
                        ////to the original schema

                        AuxilliarySchema aux = new AuxilliarySchema();
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));//"cc" + ++countBIEImports);
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();

                        String schemaName = "";
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnUseAlias);

                        determineImportOrInclude(schema, importPath, aux.Namespace);

                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;

                        //add the schema to local alreadyCreatedSchema
                        this.alreadyCreatedSchemas.Add(aux);
                        #endregion
                    }
                }

                //Is this schema already included in local array?
                if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "")
                {
                    if (!this.blnIncludeLinkedSchema) //CC_Utils.blnLinkedSchema)
                    {
                        #region "Include linked schema unchecked - for local generation only"
                        ////PRIMLibrary, how to handle?? 25 Sept 08
                        if (!(classifierPackage.Element.Stereotype == CCTS_Types.ENUMLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.DOCLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.CDTLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.QDTLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.BIELibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.CCLibrary.ToString()
                            ))
                        {
                            throw new XMLException("Schema generation from package with stereotype " + stereotype + " is not supported.");
                        }

                        AuxilliarySchema aux = new AuxilliarySchema();
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
                        this.alreadyCreatedSchemas.Add(aux);

                        String schemaName = "";
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnUseAlias);

                        determineImportOrInclude(schema, importPath, aux.Namespace);

                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;
                        #endregion
                    }
                    else
                    {
                        #region Included linked schema
                        //Create an Auxilliary schema and store it in the collection - later we have to
                        //add it to the main schema collection
                        AuxilliarySchema aux = new AuxilliarySchema();
                        System.Collections.ICollection result = null;

                        if (stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                        {
                            result = new CDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "udt" + ++countUDTImports);
                        }
                        else if (stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                        {
                            if (this.isAnyLevelGeneration)
                            {
                                //result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.blnUseAlias, 
                                    this.blnIncludeLinkedSchema, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                            }
                            else
                            {
                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(classifierPackage);
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                            }
                        }
                        else if (stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                        {
                            result = new ENUMGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "enum" + ++countENUMImports);
                        }
                        else
                        {
                            throw new XMLException("Schema generation from package with stereotype " + stereotype + " is not supported.");
                        }

                        //We get the namespace for the newly created QDTLibrary-Schema from the package name
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
                        aux.Schemas = result;

						//Add the name of the already-generated schema to local array
                        this.alreadyCreatedSchemas.Add(aux);

						//Add the name of the already-generated schema to global array for any-level generation
                        if (isAnyLevelGeneration)
                            this.alreadyCreatedSchemasBLGen.Add(aux);

                        String schemaPath = "";
                        String schemaName = "";
                        schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, this.blnUseAlias);
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        //Write the schema(s)
                        foreach (XmlSchema schema1 in result)
                        {
                            //It is possible, that more than one schema is returned here (because the
                            //auxilliary schemas may have interdependencies
                            //write only the one where the namespace fits to the one we initally created
                            if (schema1.TargetNamespace.Equals(aux.Namespace))
                            {
                                String filename = path + schemaPath + schemaName;
                                //Create the path
                                System.IO.Directory.CreateDirectory(path + schemaPath);
                                Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                                schema1.Write(outputStream);
                                outputStream.Close();
                            }
                        }

                        //We need to add an import statement for the newly generated schema
                        //to the original schema
                        String importPath = XMLTools.getImportPathForSchema(classifierPackage, repository, schemaName, scope, this.blnUseAlias);
                        determineImportOrInclude(schema, importPath, aux.Namespace);
                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);
                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;
                        #endregion
                    }
                }
                
                e.SchemaTypeName = new XmlQualifiedName(bbie.Type + "Type", s);


            }
            catch (Exception ex)
            {
                this.appendWarnMessage("Unable to determine correct datatype for attribute " + bbie.Name + " in element " + element.Name + " caused by this error : " + ex.Message + "\n Taking xsd:string instead. ", this.getPackageName());
                e.SchemaTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
            }


        }

        private  System.Collections.ICollection GetSchemaAlreadyCreated(string packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemas)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Schemas;
            }
            return null;
        }


        /// <sUMM2ary>
        /// Returns an empty String if the schema is not included
        /// If the schema is included, the namespace is returned
        /// </sUMM2ary>
        /// <param name="packageName"></param>
        /// <returns></returns>
        private  String isSchemaAlreadyIncluded(String packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemas)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }



        /// <sUMM2ary>
        /// Add a new import to the schema
        /// </sUMM2ary>
        /// <param name="schema"></param>
        internal void addImport(XmlSchema schema, String schemaLocation, String namespace_)
        {
            XmlSchemaImport xsi1 = new XmlSchemaImport();
            xsi1.SchemaLocation = schemaLocation;
            xsi1.Namespace = namespace_;
            schema.Includes.Add(xsi1);
        }

        /// <sUMM2ary>
        /// Add a new import to the schema
        /// </sUMM2ary>
        /// <param name="schema"></param>
        internal void addInclude(XmlSchema schema, String schemaLocation, String namespace_)
        {
            XmlSchemaInclude xsi1 = new XmlSchemaInclude();
            xsi1.SchemaLocation = schemaLocation;
            //xsi1.Namespaces. = namespace_;
            schema.Includes.Add(xsi1);
        }


        

        /// <sUMM2ary>
        /// Adds the necessary Namespaces to the Schema
        /// </sUMM2ary>
        /// <param name="schema"></param>
        internal  void addNameSpaces(XmlSchema schema)
        {
            string schemaNamespace = "";

            schema.Namespaces.Add("xsd", "http://www.w3.org/2001/XMLSchema");
            schema.Namespaces.Add("ccts", "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
            
            //Catch if the baseURN tagged value is empty
            schemaNamespace = XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope)));
            if (schemaNamespace == "")
                throw new Exception("Please fill the 'baseURN' tagged value of the package. 'baseURN' tagged value can not be empty.");

            schema.Namespaces.Add(XMLTools.getNameSpacePrefix(this.repository.GetPackageByID(Int32.Parse(this.scope)), this.TargetNameSpacePrefix), schemaNamespace);
            schema.TargetNamespace = schemaNamespace;
        }


        /// <sUMM2ary>
        /// Checks whether the passed element is in the same package as the acutal package we are operating on
        /// </sUMM2ary>
        /// <param name="e"></param>
        /// <returns></returns>
        private  bool isInSamePackage(EA.Element e)
        {
            if (Int32.Parse(scope) == e.PackageID)
                return true;
            else
                return false;
        }

        /// <sUMM2ary>
        /// This methods determins, what should be passed to an auxilliary schema generator
        /// If this class itself has already been called by another class, the calling class is passed
        /// otherwise an instance of this class is passed
        /// </sUMM2ary>
        /// <returns></returns>
        private  GeneratorCallBackInterface getCaller()
        {
            if (this.caller == null)
                return this;
            else
                return caller;
        }


        private  String TargetNameSpacePrefix
        {
            get { return targetNameSpacePrefix; }
            set { targetNameSpacePrefix = value; }
        }

        private  string isAlreadyInBLGenArray(string packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemasBLGen)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }

        private  string DeterminePrefix(Package importPackage)
        {
            if (importPackage.Element.Stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                return "udt" + ++countUDTImports;
            else
                if (importPackage.Element.Stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                    return "enum" + ++countENUMImports;
                else
                    if (importPackage.Element.Stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                        return "qdt" + ++countQDTImports;
                    else
                        throw new XMLException("");

            //return "";
        }

        #endregion

    }
}
