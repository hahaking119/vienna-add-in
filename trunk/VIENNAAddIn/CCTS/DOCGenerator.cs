/*******************************************************************************
This file is part of the VIENNAAddIn project

Licensed under GNU General Public License V3 http://gplv3.fsf.org/

For further information on the VIENNAAddIn project please visit 
http://vienna-add-in.googlecode.com
*******************************************************************************/
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using VIENNAAddIn.Utils;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using VIENNAAddIn.Exceptions;
using VIENNAAddIn.CCTS.CCTSBIE_MetaModel;
using VIENNAAddIn.common;
using VIENNAAddIn.constants;
using EA;

namespace VIENNAAddIn.CCTS
{

    public partial class DOCGenerator : Form, GeneratorCallBackInterface
    {

        #region Variables
        private EA.Repository repository = null;
        internal String scope = "";
        private bool annotate = false;
        private GeneratorCallBackInterface caller = null;
        //Might be used in future versions
        private bool withGUI = true;
        internal bool blnNillable = false;
        private bool blnIncludeLinkedSchema = false;
        private bool blnAlias = false;
        
        private bool DEBUG;

        //The path where the generated schema(s) will be saved
        private String path = "";
        private String targetnameSpacePrefix = "doc";

        //This ArrayList holds a List of all auxilliary schmeas
        //that had to be created for this schema to be valid
        //it only hold the auxilliary schema in a pacakage
        private System.Collections.ArrayList alreadyCreatedSchemas = new ArrayList();

        //This arraylist hold a list of auxilliary schema that generated by BusinessLibraryGenerator
        private ArrayList alreadyCreatedSchemasBLGen;

        //if generate from anyLevel, its value will be true, otherwise if generated from specific package it will be false;
        private bool isAnyLevelGeneration = false;

        private String[,] rootElements = null;
        //This variable holds the diagram from which we retrieve the DOCLibrary logic
        //By definition there can only be one diagram in a DOCLibrary
        private EA.Diagram sourceDiagram;

        //These variables are used to make a distinction between namespaces of the same type
        static int countQDTImports = 0;
        static int countUDTImports = 0;
        static int countENUMImports = 0;
        static int countBIEImports = 0;
        #endregion

        #region Constructor
        /// <summary>
        /// Minimal Constructor for loading DOCGenerator form
        /// </summary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        public DOCGenerator(EA.Repository repository, String scope, bool annotate)
        {

            //DEBUG = Utility.DEBUG;

            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.isAnyLevelGeneration = false;

            InitializeComponent();

            this.setActivePackageLabel();
            this.fillChoiceBox();
        }


        /// <summary>
        /// Constructor for linked schema
        /// </summary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        public DOCGenerator(EA.Repository repository, String scope, bool annotate, bool blnIncludeLinkedSchema, 
            bool blnUseAlias, bool blnNillable, string path, GeneratorCallBackInterface prmCaller)
        {

            //DEBUG = Utility.DEBUG;

            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
            this.blnAlias = blnUseAlias;
            this.blnNillable = blnNillable;
            this.isAnyLevelGeneration = false;
            this.path = path;

            this.caller = prmCaller;
            this.withGUI = false;
        }

        /// <summary>
        /// This constructor is made special for any-level schema generation
        /// </summary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        /// <param name="path"></param>
        /// <param name="alreadyCreatedSchemasBLGen"></param>
        public DOCGenerator(EA.Repository repository, String scope, bool annotate, bool blnNillable, 
            bool blnIncludeLinkedSchema, bool blnUseAlias, string path, ArrayList alreadyCreatedSchemasBLGen, 
            GeneratorCallBackInterface caller)
        {
            //DEBUG = Utility.DEBUG;

            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.blnNillable = blnNillable;
            this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
            this.blnAlias = blnUseAlias;
            
            this.withGUI = false;

            this.path = path;
            this.alreadyCreatedSchemasBLGen = alreadyCreatedSchemasBLGen;
            this.isAnyLevelGeneration = true;

            
            this.caller = caller;
        }

        ///// <summary>
        ///// Constructor
        ///// </summary>
        ///// <param name="repository"></param>
        ///// <param name="scope"></param>
        //public DOCGenerator(EA.Repository repository, bool annotate)
        //{

        //    DEBUG = Utility.DEBUG;

        //    this.repository = repository;
        //    this.scope = ""; // will be setted later
        //    this.annotate = annotate;
        //    this.withGUI = false;
        //    this.isAnyLevelGeneration = false;

        //}
        #endregion

        /// <summary>
        /// Reset the GeneratorWindow
        /// </summary>
        public void resetGenerator(String scope)
        {
            //Reset the counters for the imports
            countQDTImports = 0;
            countUDTImports = 0;
            countENUMImports = 0;
            countBIEImports = 0;
            //Already created schemas must be set back
            this.alreadyCreatedSchemas = new ArrayList();
            this.scope = scope;
            this.statusTextBox.Text = "";
            this.progressBar1.Value = this.progressBar1.Minimum;
            setActivePackageLabel();

        }



        /// <summary>
        /// Set the text of the textbox which indicates, which business information
        /// view has been chosen and fill the choice box with possible root elements
        /// </summary>
        private void setActivePackageLabel()
        {
            EA.Package p = this.repository.GetPackageByID(Int32.Parse(this.scope));
            this.selectedBusinessInformationView.Text = p.Name.ToString();

            //Get the elements from the diagram and show them as possible root elements
            

        }



        /// <summary>
        /// Fill the choiceBox with possible root elements
        /// </summary>
        public void fillChoiceBox()
        {
            //clean choice box 
            this.cbxRootElement.Items.Clear();
            this.cbxRootElement.Text = "";

            EA.Package p = this.repository.GetPackageByID(Int32.Parse(scope));

            int countElements = 0;
            foreach (EA.Element e in p.Elements)
            {
                if (e.Stereotype.ToString() == CCTS_Types.ABIE.ToString() &&
                    this.elementIsRootElement(e))
                {
                    countElements++;
                }
            }

            //Define a 2dimensional Array which will hold the name of the root Element
            //and its element id
            String[,] rootElements = new String[countElements, 2];
            int i = 0;
            foreach (EA.Element e in p.Elements)
            {

                if (e.Stereotype.ToString() == CCTS_Types.ABIE.ToString()
                    && this.elementIsRootElement(e))
                {
                    rootElements[i, 0] = e.Name + " (" + e.Stereotype.ToString() + ")";
                    rootElements[i, 1] = e.ElementID.ToString();
                    i++;
                }
            }
            //save the root elements as class variable so we can use them later
            this.rootElements = rootElements;

            //Add the potential root elements to the choice box
            this.cbxRootElement.Items.Clear();
            for (int j = 0; j < countElements; j++)
            {
                this.cbxRootElement.Items.Add(rootElements[j, 0]);
            }

        }







        /// <summary>
        /// There must be at max 1 diagram in a business information view
        /// </summary>
        /// <returns></returns>
        private bool checkIfThereIsOnlyOneDiagram()
        {
            EA.Package p = this.repository.GetPackageByID(Int32.Parse(scope));
            if (p.Diagrams.Count == 1)
            {
                this.sourceDiagram = (EA.Diagram)p.Diagrams.GetAt(0);
                return true;
            }
            else
                return false;

        }

        /// <summary>
        /// Cancel button
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void button2_Click(object sender, EventArgs e)
        {
            this.resetGenerator(this.scope);
            this.cbxRootElement.Text = "";
            this.Close();
        }

        private void getCheckedOption()
        {
            if (this.chkAnnotate.Checked)
                this.annotate = true;
            else
                this.annotate = false;

            if (this.chkIncludeLinkedSchema.Checked)
                this.blnIncludeLinkedSchema = true;
            else
                this.blnIncludeLinkedSchema = false;

            if (this.chkUseAlias.Checked)
                this.blnAlias = true;
            else
                this.blnAlias = false;

            if (this.chkNillable.Checked)
                this.blnNillable = true;
            else
                this.blnNillable = false;
        }

        /// <summary>
        /// Start the schema generation
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void generateButton_Click(object sender, EventArgs e)
        {
            resetGenerator(this.scope);
            
            getCheckedOption();
            
            //Annotate or not?
            //if (this.checkBox1.Checked)
            //    this.annotate = true;
            //else
            //    this.annotate = false;

            //if (this.chkIncludeLinkedSchema.Checked)
            //    CC_Utils.blnLinkedSchema = true;
            //else
            //    CC_Utils.blnLinkedSchema = false;

            ////use alias for generated package or not?
            //if (this.chkUseAlias.Checked)
            //    CC_Utils.blnUseAlias = true;
            //else
            //    CC_Utils.blnUseAlias = false;


            //Get the selected root element
            String selectedRootElement = this.cbxRootElement.Text;

            DialogResult dr = this.folderBrowserDialog1.ShowDialog(this);
            if (dr.Equals(DialogResult.Cancel))
            {
                folderBrowserDialog1.Dispose();
                return;
            }

            path = this.folderBrowserDialog1.SelectedPath;


            //No path - raise an error
            if (this.path == null || this.path.Equals(""))
            {
                this.appendErrorMessage("Please select a location for the generated schemas first.", this.getPackageName());
            }
            //No root element - raise an error
            else if (selectedRootElement == "")
            {
                this.appendErrorMessage("Please select a root element first.", this.getPackageName());
            }
            else
            {

                this.path = this.path + "\\";
                //Get the active Package
                EA.Package p = this.repository.GetPackageByID(Int32.Parse(this.scope));
                String error = "";
                this.performProgressStep();

                System.Collections.ICollection result = null;

                this.appendInfoMessage("Starting DOC schema creation. Please wait.", this.getPackageName());

                try
                {
                    result = generateSchema(getSelectedElement(), p);
                }
                catch (Exception exc)
                {
                    error = exc.Message;
                }

                //No error occurred - write the result
                if (error == "")
                {
                    string baseURL = XMLTools.getBaseURL(repository, this.scope);

                    foreach (XmlSchema schema in result)
                    {
                        String schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(Int32.Parse(this.scope)), repository, this.blnAlias);
                        String filename = path + schemaPath + XMLTools.getSchemaName(this.repository.GetPackageByID(Int32.Parse(this.scope)));
                        //Create the path
                        System.IO.Directory.CreateDirectory(path + schemaPath);
                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                        schema.Write(outputStream);
                        outputStream.Close();

                        if (baseURL != "")
                        {
                            EA.Package pkg = this.repository.GetPackageByID(Int32.Parse(this.scope));
                            string schemaName2 = XMLTools.getSchemaName(this.repository.GetPackageByID(Int32.Parse(this.scope)));
                            string webSchemaPath = baseURL + "/" + schemaPath.Replace("\\", "/") + schemaName2;

                            //add the address to property of package
                            if (!IsSchemaExist(webSchemaPath, pkg))
                            {
                                EA.File myfile = (EA.File)pkg.Element.Files.AddNew(webSchemaPath, "Web Address");

                                myfile.Update();
                                pkg.Element.Files.Refresh();
                            }
                        }
                    }
                    this.appendInfoMessage("The schema was created successfully.", this.getPackageName());
                }
                else
                {
                    this.appendErrorMessage(error, this.getPackageName());
                }

                this.progressBar1.Value = this.progressBar1.Maximum;
                
            }
        }


        /// <summary>
        /// Search for particular webSchemaPath
        /// </summary>
        /// <param name="webSchemaPath">Web address for schema</param>
        /// <param name="pkg">Package</param>
        /// <returns></returns>
        private bool IsSchemaExist(string webSchemaPath, EA.Package pkg)
        {
            foreach (EA.File file in pkg.Element.Files)
            {
                if (file.Name == webSchemaPath)
                    return true;
            }
            return false;
        }


        /// <summary>
        /// Return the selected root element
        /// </summary>
        /// <returns></returns>
        private int getSelectedElement()
        {
            String text = this.cbxRootElement.Text;
            for (int i = 0; i < this.rootElements.Length; i++)
            {
                if (rootElements[i, 0] == text)
                {
                    return Int32.Parse(rootElements[i, 1]);
                }
            }
            return -1;
        }


        /// <summary>
        /// Generates a schema from the QDTs
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public System.Collections.ICollection generateSchema(int rootElementID, EA.Package p)
        {

            XmlSchema schema = new XmlSchema();

            //add version of this UMM Add-In
            XMLTools.addVersionComment(schema);

            schema.ElementFormDefault = XmlSchemaForm.Qualified;
            schema.AttributeFormDefault = XmlSchemaForm.Unqualified;
            schema.Version = XMLTools.getSchemaVersionFromPackage(p);

            //Add the Namespaces necessary for the BIE schema
            addNameSpaces(schema);

            //Add the import schemas
            addImports(schema);

            //Iterate through the ABIEs in order to generate the schema            
            iterate(this.repository.GetElementByID(rootElementID), schema, true);

            //A DOC Library has exactly one root element
            addRootElement(schema, rootElementID);

            //Now validate the Schema
            XmlSchemaSet xsdSet = new XmlSchemaSet();
            xsdSet.XmlResolver = null;
            xsdSet.ValidationEventHandler += new ValidationEventHandler(ValidationCallbackOne);
            try
            {
                xsdSet.Add(schema);
                //xsdSet.Compile();
            }
            catch (XmlSchemaException xse)
            {
                throw xse;
            }

            this.performProgressStep();

            return xsdSet.Schemas();

        }


        /// <summary>
        /// Generates a schema from the QDTs
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        public System.Collections.ICollection generateSchema(EA.Package p)
        {

            XmlSchema schema = new XmlSchema();

            //add version of this UMM Add-In
            XMLTools.addVersionComment(schema);

            schema.ElementFormDefault = XmlSchemaForm.Qualified;
            schema.AttributeFormDefault = XmlSchemaForm.Unqualified;
            schema.Version = XMLTools.getSchemaVersionFromPackage(p);

            //Add the Namespaces necessary for the BIE schema
            addNameSpaces(schema);

            //Add the import schemas
            addImports(schema);

            foreach (EA.Element element in p.Elements)
            {
                if (isRoot(element))
                {
                    int rootElementID = element.ElementID;
                    //Iterate through the ABIEs in order to generate the schema            
                    iterate(this.repository.GetElementByID(rootElementID), schema, true);
                    addRootElement(schema, rootElementID);
                }
            }

            

            //Now validate the Schema
            XmlSchemaSet xsdSet = new XmlSchemaSet();
            xsdSet.XmlResolver = null;
            xsdSet.ValidationEventHandler += new ValidationEventHandler(ValidationCallbackOne);
            try
            {
                xsdSet.Add(schema);
                //xsdSet.Compile();
            }
            catch (XmlSchemaException xse)
            {
                //MessageBox.Show(xse.StackTrace.ToString());
                throw xse;
            }

            this.performProgressStep();

            return xsdSet.Schemas();

        }

        /// <summary>
        /// Check an element whether it has an isRoot tagged value or not
        /// </summary>
        /// <param name="element">element</param>
        /// <returns>boolean value</returns>
        private bool isRoot(EA.Element element)
        {
            foreach (EA.TaggedValue tv in element.TaggedValues)
            {
                if ((tv.Name.Equals("isRoot", StringComparison.OrdinalIgnoreCase)) &&
                    (tv.Value.Equals("true", StringComparison.OrdinalIgnoreCase)))
                {
                    return true;
                }
            }
            return false;
        }


        /// <summary>
        /// Adds the root element to the schema
        /// </summary>
        /// <param name="schema"></param>
        /// <param name="rootElementID"></param>
        private void addRootElement(XmlSchema schema, int rootElementID)
        {
            EA.Element e = this.repository.GetElementByID(rootElementID);
            //EA.Package package = this.repository.GetPackageByID(e.PackageID);

            XmlSchemaElement rootElement = new XmlSchemaElement();
            rootElement.Name = XMLTools.getXMLName(e.Name);
            rootElement.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(e.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));

            schema.Items.Add(rootElement);

        }



        /// <summary>
        /// Returns the ABIEs, BBIEs and ASBIEs
        /// </summary>
        /// <param name="abie"></param>
        /// <param name="schema"></param>
        private void iterate(EA.Element element, XmlSchema schema, bool isRoot)
        {
            //Create a new ComplexType for the passed Element
            //if it does not already exist
            //A ComplexType will only be created if the element is from the acutal
            //package
            XmlSchemaElement e = new XmlSchemaElement();
            if (checkIfElementIsFromActualPackage(element))
            {
                #region The element is in the same package with root element
                //Does the complex already exist
                if (!XMLTools.isElementAlreadyIncludedInSchema(schema, XMLTools.getXMLName(element.Name) + "Type"))
                {

                    e.Name = XMLTools.getXMLName(element.Name);
                    XmlSchemaComplexType ct = new XmlSchemaComplexType();
                    ct.Name = e.Name + "Type";
                    XmlSchemaSequence seq = new XmlSchemaSequence();

                    ArrayList tempPostion = new ArrayList();
                    ArrayList tempNoPostion = new ArrayList();

                    #region sort attribute then add to sequence
                    foreach (EA.Attribute attr in element.Attributes)
                    {
                        SearchAttributeForPositionTaggedValue(attr, tempPostion, tempNoPostion);
                    }

                    #endregion

                    #region search for connector with diamond
                    //Now check, whether there are any ASBIEs                      
                    foreach (EA.Connector con in element.Connectors)
                    {
                        if (con.Type.ToString() == EA_Element.Aggregation.ToString() &&
                            con.Stereotype.ToString() == CCTS_Types.ASBIE.ToString() && con.SupplierID == element.ElementID)
                        {
                            EA.ConnectorEnd clientEnd = con.ClientEnd;
                            EA.Element client = this.repository.GetElementByID(con.ClientID);
                            EA.Element supplier = this.repository.GetElementByID(con.SupplierID);

                            //Is the connection type an Aggregation or a Composition? A composition == 2
                            bool isComposition = false;
                            if (con.SupplierEnd.Aggregation == 2)
                            {
                                isComposition = true;
                            }

                            String elementName = "";
                            //If a role name is specified, the following pattern applies for a name: Role.Name + Client.Name                            
                            if (clientEnd.Role != "")
                            {
                                elementName = XMLTools.getXMLName(clientEnd.Role + client.Name);
                            }
                            else //If no role name is specified, the following pattern applies for a name: Client.Name
                            {
                                elementName = XMLTools.getXMLName(client.Name);
                            }

                            XmlSchemaElement elemRef = new XmlSchemaElement();
                            
                            //Annotate?
                            if (annotate)
                                elemRef.Annotation = new BIEGenerator(this.repository, this.scope).getASBIEAnnotation(con); //new CommonRoutineCCBIE().getASBIEAnnotation(con);

                            //aggregation or composition is treated the same way - for quick fix
                            //if (isComposition) {
                            elemRef.Name = elementName;

                            //Is the ABIE from the current package?
                            if (checkIfElementIsFromActualPackage(client))
                            {
                                elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            }
                            else
                            {
                                //The ABIE is not from the current package 
                                //Determine the namespace of the package, where the ABIE is from
                                elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(client.PackageID)));
                            }

                            #region old code
                            //}
                            //else {

                            //    XmlSchemaElement xel = new XmlSchemaElement();
                            //    xel.Name = elementName;

                            //    ////Is the ABIE from the current package?
                            //    if (checkIfElementIsFromActualPackage(client)) {
                            //        xel.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //    }
                            //    else {
                            //        //The ABIE is not from the current package
                            //        //Determine the namespace of the package, where the
                            //        //ABIE is from
                            //        xel.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(client.PackageID)));
                            //    }

                            //    schema.Items.Add(xel);
                            //    elemRef.RefName = new XmlQualifiedName(elementName, XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //}
                            #endregion

                            //Set the cardinality of the element
                            new BIEGenerator(this.repository, this.scope).setASBIECardinality(elemRef, clientEnd.Cardinality);
                            //new CommonRoutineCCBIE().setASBIECardinality(elemRef, clientEnd.Cardinality);

                            SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);
                        }
                    }
                    #endregion

                    #region Sort the BBIE and ASBIE
                    //sort connector, then insert it into sequence
                    SortByPosition comparerPosition = new SortByPosition();
                    SortByName comparerName = new SortByName();

                    tempPostion.Sort(comparerPosition);
                    tempNoPostion.Sort(comparerName);

                    //sort the element with "position" tagged value
                    foreach (object obj in tempPostion)
                    {
                        if (((ArrayList)obj)[2].ToString() == "Attribute")
                        {
                            EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                            if (attribute.Stereotype.Equals(CCTS_Types.BBIE.ToString()))
                            {
                                XmlSchemaElement attrElem = new XmlSchemaElement();
                                attrElem.Name = XMLTools.getXMLName(attribute.Name);
                                //Set the type
                                setBBIEType(attrElem, attribute, schema, element);
                                //Set the cardinality
                                setBBIECardinality(attrElem, attribute);
                                //Get the annotation
                                if (annotate)
                                    attrElem.Annotation = new BIEGenerator(this.repository, this.scope).getBBIEAnnotation(attribute); //new CommonRoutineCCBIE().getBBIEAnnotation(attribute); 
                                //check for lower cardinality, if lower bound = 0, add nillable attribute
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                                //Add the element to the sequence
                                seq.Items.Add(attrElem);
                            }
                        }
                        else if (((ArrayList)obj)[2].ToString() == "Connector")
                        {
                            XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                            seq.Items.Add(schemaElement);
                        }

                    }

                    //sort the element alphabetically
                    foreach (object obj in tempNoPostion)
                    {
                        if (((ArrayList)obj)[2].ToString() == "Attribute")
                        {
                            EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                            if (attribute.Stereotype.Equals(CCTS_Types.BBIE.ToString()))
                            {
                                XmlSchemaElement attrElem = new XmlSchemaElement();
                                attrElem.Name = XMLTools.getXMLName(attribute.Name);
                                //Set the type
                                setBBIEType(attrElem, attribute, schema, element);
                                //Set the cardinality
                                setBBIECardinality(attrElem, attribute);
                                //Get the annotation
                                if (annotate)
                                    attrElem.Annotation = new BIEGenerator(this.repository, this.scope).getBBIEAnnotation(attribute); //new CommonRoutineCCBIE().getBBIEAnnotation(attribute); 
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                                //Add the element to the sequence
                                seq.Items.Add(attrElem);
                            }
                        }
                        else if (((ArrayList)obj)[2].ToString() == "Connector")
                        {
                            XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                            seq.Items.Add(schemaElement);
                        }
                    }

                    //generate warning if there is a mix sort, alphabetically and sequence
                    if ((tempPostion.Count > 0) && (tempNoPostion.Count > 0))
                    {
                        this.appendWarnMessage("There is a mix of sequence and alphabetic sorting of attributes (BBIEs) and aggregations (ASBIEs)", this.getPackageName());
                    }

                    #endregion

                    //Add the complex type to the schema if it does not alreday exist
                    ct.Particle = seq;
                    schema.Items.Add(ct);

                    //Scope contains the DOCLibrary package
                    e.SchemaTypeName = new XmlQualifiedName(e.Name + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(scope))));


                    //Iterate recursively               
                    //foreach (EA.Connector con in element.Connectors) -- don't use foreach with recursive loop inside, it will crash in release build!!
                    for (short a = 0; a < element.Connectors.Count; a++) 
                    {
                        EA.Connector con = (EA.Connector)element.Connectors.GetAt(a);
                        if (con.Type.ToString() == EA_Element.Aggregation.ToString() &&
                            con.Stereotype.ToString() == CCTS_Types.ASBIE.ToString())
                        {
                            EA.Element client = this.repository.GetElementByID(con.ClientID);
                            //DOCGenerator docGen = new DOCGenerator(this.repository, this.scope, this.annotate,
                            //    this.blnIncludeLinkedSchema, this.blnAlias, this.blnNillable, this.path);
                            iterate(client, schema, false);
                        }
                    }
                }
                #endregion
            }
            else
            {
                //Element is not from the actual package - create and import the relevant schema(s)
                e.SchemaTypeName = createAndImportAuxilliarySchema(element, schema);
            }

        }


        /// <summary>
        /// Returns true, if the element is part of the diagram
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        private bool isElementinDiagram(EA.Element e)
        {

            bool found = false;
            foreach (EA.DiagramObject dobj in this.sourceDiagram.DiagramObjects)
            {
                if (dobj.ElementID == e.ElementID)
                {
                    found = true;
                    break;
                }
            }
            return found;
        }





        /// <summary>
        /// Sets the cardinality of the element according to the information in the 
        /// BasicBusinessInformationEntity
        /// </summary>
        /// <param name="e1"></param>
        /// <param name="abie"></param>
        private void setBBIECardinality(XmlSchemaElement e1, EA.Attribute bbie)
        {

            //Set Lower Bound            
            try
            {
                int lower = Int32.Parse(bbie.LowerBound);
                e1.MinOccurs = lower;
            }
            catch (Exception e) { }

            //Set Upper Bound
            try
            {
                if (bbie.UpperBound == "*")
                {
                    e1.MaxOccursString = "unbounded";
                }
                else
                {
                    int upper = Int32.Parse(bbie.UpperBound);
                    //We do not need to consider 1 as this is the default value
                    if (upper != 1)
                        e1.MaxOccurs = upper;
                }
            }
            catch (Exception e) { }
        }




        /// <summary>
        /// Sets the type of the given bbie
        /// If the type refers to a cdt/qdt the method first checks,
        /// whether the relevant schema does already exist
        /// If not the schema is created and a reference via import statement
        /// is made
        /// </summary>
        /// <param name="e"></param>
        /// <param name="bbie"></param>
        private void setBBIEType(XmlSchemaElement e, EA.Attribute bbie, XmlSchema schema, EA.Element element)
        {

            try
            {

                String type = bbie.Type;
                bool isBuildInBBIEType = false;

                //If no classifier is set, a build in datatype has been taken
                int classifierID = bbie.ClassifierID;
                EA.Element classifierElement = null;
                try
                {
                    classifierElement = this.repository.GetElementByID(classifierID);
                }
                catch (Exception exec)
                {
                    isBuildInBBIEType = true;
                }

                if (!isBuildInBBIEType)
                {

                    EA.Package classifierPackage = this.repository.GetPackageByID(classifierElement.PackageID);
                    String stereotype = classifierPackage.Element.Stereotype;

                    //Is this schema already included?
                    String s = "";

                    //if the generation is from any level generation
                    if (isAnyLevelGeneration)
                    {
                        String sBLGen = "";
                        if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(classifierPackage.Name)) != "")
                        {
                            #region for any level package generation, to check if there was previously generated schema
                            ////We need to add an import statement for the newly generated schema
                            ////to the original schema

                            AuxilliarySchema aux = new AuxilliarySchema();
                            aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));
                            aux.PackageOfOrigin = classifierPackage.Name.ToString();

                            String schemaName = "";
                            schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                            String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnAlias);

                            addImport(schema, importPath, aux.Namespace);

                            //We need to add the namespace of this schema to the main schema
                            schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                            //Set the namespace to the variable which is then used down below
                            s = aux.Namespace;

                            //add the schema to local alreadyCreatedSchema
                            this.alreadyCreatedSchemas.Add(aux);
                            #endregion
                        }
                    }

                    if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "")
                    {
                        if (!this.blnIncludeLinkedSchema) ///CC_Utils.blnLinkedSchema)
                        {
                            #region Include linked schema unchecked - for local generation only
                            AuxilliarySchema aux = new AuxilliarySchema();
                            aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));
                            aux.PackageOfOrigin = classifierPackage.Name.ToString();
                            this.alreadyCreatedSchemas.Add(aux);

                            String schemaName = "";
                            schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                            String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnAlias); //CC_Utils.blnUseAlias);

                            addImport(schema, importPath, aux.Namespace);

                            //We need to add the namespace of this schema to the main schema
                            schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                            //Set the namespace to the variable which is then used down below
                            s = aux.Namespace;
                            #endregion
                        }
                        else
                        {
                            #region Included linked schema Checked
                            //Create an Auxilliary schema and store it in the collection - later we have to
                            //add it to the main schema collection
                            AuxilliarySchema aux = new AuxilliarySchema();
                            System.Collections.ICollection result = null;

                            if (stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                            {
                                result = new CDTGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(classifierPackage);
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "udt" + ++countUDTImports);
                            }
                            else if (stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                            {
                                //if isAnyLevelGeneration=true, then set the linked-schema's variable isAnyLevelGeneration = true;
                                //to avoid repetitive generation of a schema
                                //why only QDTLibrary? because QDTLibrary can import ENUMLib, CDTLib
                                //ENUMLib and CDTLib doesn't import anything bcoz it's a primitif or core/basic datatype, 
                                //so isAnyLeveGeneration doesn't need to be passed to ENUMLIB n CDTLib.
                                if (isAnyLevelGeneration)
                                {
                                    //result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                    result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.blnAlias, 
                                        this.blnIncludeLinkedSchema, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                                }
                                else
                                {
                                    result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, 
                                        this.blnIncludeLinkedSchema, this.blnAlias, this.path, getCaller()).generateSchema(classifierPackage);
                                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                                }
                            }
                            else if (stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                            {
                                result = new ENUMGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(classifierPackage);
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "enum" + ++countENUMImports);
                            }
                            else
                            {
                                throw new XMLException("Unknown stereotype.");
                            }

                            //We get the namespace for the newly created QDTLibrary-Schema from the package name
                            aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                            aux.PackageOfOrigin = classifierPackage.Name.ToString();
                            aux.Schemas = result;

                            //Add the name of the already-generated schema to local array
                            this.alreadyCreatedSchemas.Add(aux);

                            //Add the name of the already-generated schema to global array for any-level generation
                            if (isAnyLevelGeneration)
                                this.alreadyCreatedSchemasBLGen.Add(aux);

                            String schemaPath = "";
                            String schemaName = "";
                            schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, this.blnAlias); //CC_Utils.blnUseAlias);
                            schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                            //Write the schema(s)
                            foreach (XmlSchema schema1 in result)
                            {
                                //It is possible, that more than one schema is returned here (because the
                                //auxilliary schemas may have interdependencies
                                //write only the one where the namespace fits to the one we initally created
                                if (schema1.TargetNamespace.Equals(aux.Namespace))
                                {
                                    String filename = path + schemaPath + schemaName;
                                    //Create the path
                                    System.IO.Directory.CreateDirectory(path + schemaPath);
                                    Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                                    schema1.Write(outputStream);
                                    outputStream.Close();
                                }
                            }

                            //We need to add an import statement for the newly generated schema
                            //to the original schema
                            String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnAlias); //CC_Utils.blnUseAlias);

                            addImport(schema, importPath, aux.Namespace);
                            //We need to add the namespace of this schema to the main schema
                            schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);
                            //Set the namespace to the variable which is then used down below
                            s = aux.Namespace;
                            #endregion
                        }
                    }

                    e.SchemaTypeName = new XmlQualifiedName(bbie.Type + "Type", s);
                }
                else
                {
                    //A buildin type
                    e.SchemaTypeName = new XmlQualifiedName(XMLTools.getXSDType(bbie, element), "http://www.w3.org/2001/XMLSchema");
                }


            }
            catch (Exception ex)
            {
                this.appendWarnMessage("Unable to determine correct datatype for attribute " + bbie.Name + " in element " + element.Name + " Please make sure, that either a classifier is set for the attribute or a primitive type is taken for the attribute. Taking xsd:string instead. ", this.getPackageName());
                e.SchemaTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
            }


        }




        /// <summary>
        /// Creates and imports relevant auxilliary schemas
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        private XmlQualifiedName createAndImportAuxilliarySchema(EA.Element e, XmlSchema schema)
        {
            //Get the package of origin of the element
            EA.Package p = this.repository.GetPackageByID(e.PackageID);
            String s = "";
            
            //if the generation is from any level generation
            if (isAnyLevelGeneration)
            {
                String sBLGen = "";
                if ((s = isSchemaAlreadyIncluded(p.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(p.Name)) != "")
                {
                    #region for any level package generation, to check if there was previously generated schema
                    ////We need to add an import statement for the newly generated schema
                    ////to the original schema

                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();

                    String schemaName = "";
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));


                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnAlias); //CC_Utils.blnUseAlias);

                    addImport(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;

                    //add the schema to local alreadyCreatedSchema
                    this.alreadyCreatedSchemas.Add(aux);
                    #endregion
                }
            }


            //Is this schema already included in local Array list?
            if ((s = isSchemaAlreadyIncluded(p.Name)) == "")
            {
                if (!this.blnIncludeLinkedSchema) //CC_Utils.blnLinkedSchema)
                {
                    #region Include linked schema unchecked - for particular generation only
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();
                    this.alreadyCreatedSchemas.Add(aux);

                    String schemaName = "";
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));

                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnAlias); //CC_Utils.blnUseAlias);

                    addImport(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;
                    #endregion
                }
                else
                {
                    #region Included linked schema
                    System.Collections.ICollection result;
                    if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.DOCLibrary.ToString())
                    {
                        if (this.isAnyLevelGeneration)
                            //result = new DOCGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
                            result = new DOCGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnNillable, 
                                this.blnIncludeLinkedSchema, this.blnAlias, this.path, this.alreadyCreatedSchemasBLGen, getCaller()).generateSchema(p);
                        else
                            result = new DOCGenerator(this.repository, p.PackageID.ToString(), annotate, 
                                this.blnIncludeLinkedSchema, this.blnAlias, this.blnNillable, this.path, getCaller()).generateSchema(p);
                    }
                    else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.BIELibrary.ToString())
                    {
                        //if (!isAlreadyInBLGenArray(p.Name))
                        //{
                            if (this.isAnyLevelGeneration)
                                //result = new BIEGenerator(this.repository, p.PackageID.ToString(), annotate, this.path,this.alreadyCreatedSchemasBLGen).generateSchema(p);
                                result = new BIEGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                                    this.blnAlias, this.blnNillable, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
                            else
                                result = new BIEGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                                    this.blnAlias, this.blnNillable, this.path, getCaller()).generateSchema(p);
                        //}
                    }
                    else
                        throw new Exception("Linked schema generation from package <<" + p.Element.Stereotype + ">>" + p.Name + "currently is not supported");

                    //Create an Auxilliary schema and store it in the collection - later we have to
                    //add it to the main schema collection
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();
                    aux.Schemas = result;

                    //Add the name of the already-generated schema to local array
                    this.alreadyCreatedSchemas.Add(aux);

                    //Add the name of the already-generated schema to global array for any-level generation
                    if (isAnyLevelGeneration)
                        this.alreadyCreatedSchemasBLGen.Add(aux);

                    String schemaPath = "";
                    String schemaName = "";
                    
                    schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository, this.blnAlias); //CC_Utils.blnUseAlias);
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
                    String filename = path + schemaPath + schemaName;

                    //Write the schema(s)
                    foreach (XmlSchema schema1 in result)
                    {
                        //Create the path
                        System.IO.Directory.CreateDirectory(path + schemaPath);
                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                        schema1.Write(outputStream);
                        outputStream.Close();
                    }
                   
                    //We need to add an import statement for the newly generated schema
                    //to the original schema
                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnAlias); //CC_Utils.blnUseAlias);

                    addImport(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;
                    #endregion
                }
            }

            


            return new XmlQualifiedName(e.Name + "Type", s);

        }

        private string isAlreadyInBLGenArray(string packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemasBLGen)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }


        /// <summary>
        /// Check whether the passed element is from the actual package or not
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        private bool checkIfElementIsFromActualPackage(EA.Element e)
        {
            if (Int32.Parse(this.scope) == e.PackageID)
                return true;
            else
                return false;
        }



        /// <summary>
        /// Performs a step with the progress bar
        /// </summary>
        public void performProgressStep()
        {
            if (this.withGUI)
            {
                this.progressBar1.PerformStep();
            }
            else
            {
                //Is there a caller for this class?
                if (caller != null)
                    caller.performProgressStep();
            }
        }



        /// <summary>
        /// Ersetzt : und white spaces
        /// </summary>
        /// <param name="n"></param>
        /// <returns></returns>
        private String adaptFileName(String n)
        {

            if (n != null && n != "")
            {
                String s = n.Replace(' ', '_');
                s = s.Replace(':', '_');
                //this is optional
                s = s.Replace("urn_un_unece_uncefact_", "");
                return s;
            }
            else
                return "";
        }




        /// <summary>
        /// Check, if the element selected is a possible root element
        /// </summary>
        /// <param name="abie"></param>
        /// <returns></returns>
        private Boolean elementIsRootElement(EA.Element abie)
        {

            //Disable this check until further notice
            return true;


            //Boolean isRoot = false;
            //EA.Collection col = abie.Connectors;

            //int rootCount = 0;
            ////int dependencyCount = 0;
            //foreach (EA.Connector con in col)
            //{

            //    //all connections must start in the element, which has the same ID as the supplier
            //    if (con.SupplierID == abie.ElementID)
            //    {
            //        rootCount++;
            //    }
            //}
            ////if the number of connectors subtract 1 equals to the counted numbers of root connectors
            ////the element is a root element
            //// minus 1 --> because there is one dependency allowed
            //if (rootCount == col.Count - 1)
            //{
            //    isRoot = true;
            //}
            //else
            //{
            //    isRoot = false;
            //}

            //return isRoot;
        }


        /// <summary>
        /// Append an error message to the status box
        /// </summary>
        /// <param name="msg"></param>
        private void appendErrorMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("error", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                {
                    this.statusTextBox.Text += "ERROR: (Package: " + packageName + ") " + msg + "\n\n";
                }
            }
        }
        /// <summary>
        /// Show a info message in the status box
        /// </summary>
        /// <param name="msg"></param>
        private void appendInfoMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("info", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                {
                    this.statusTextBox.Text += "INFO: (Package: " + packageName + ") " + msg + "\n\n";
                }
            }
        }
        /// <summary>
        /// Show a warn message in the status box
        /// </summary>
        /// <param name="msg"></param>
        private void appendWarnMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("warn", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                    this.statusTextBox.Text += "WARN: (Package: " + packageName + ") " + msg + "\n\n";
            }
        }

        /// <summary>
        /// Returns the name of the current package
        /// </summary>
        /// <returns></returns>
        private String getPackageName()
        {
            return this.repository.GetPackageByID(Int32.Parse(this.scope)).Name.ToString();
        }

        /// <summary>
        /// Add a new import to the schema
        /// </summary>
        /// <param name="schema"></param>
        private void addImport(XmlSchema schema, String schemaLocation, String namespace_)
        {
            XmlSchemaImport xsi1 = new XmlSchemaImport();
            xsi1.SchemaLocation = schemaLocation;
            xsi1.Namespace = namespace_;
            schema.Includes.Add(xsi1);
        }

        /// <summary>
        /// Adds the necessary Namespaces to the Schema
        /// </summary>
        /// <param name="schema"></param>
        private void addNameSpaces(XmlSchema schema)
        {
            string schemaNamespace = "";

            schema.Namespaces.Add("xsd", "http://www.w3.org/2001/XMLSchema");
            schema.Namespaces.Add("ccts", "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");

            //Catch if the baseURN tagged value is empty
            schemaNamespace = XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope)));
            if (schemaNamespace == "")
                throw new Exception("Please fill the 'baseURN' tagged value of the package. 'baseURN' can not be empty.");

            schema.Namespaces.Add(XMLTools.getNameSpacePrefix(this.repository.GetPackageByID(Int32.Parse(this.scope)), this.TargetNameSpacePrefix), schemaNamespace);
            schema.TargetNamespace = schemaNamespace;
        }


        /// <summary>
        /// Add the necessary Imports
        /// </summary>
        /// <param name="schema"></param>
        private void addImports(XmlSchema schema)
        {
            //Nothing to do so far
        }

        /// <summary>
        /// Returns an empty String if the schema is not included
        /// If the schema is included, the namespace is returned
        /// </summary>
        /// <param name="packageName"></param>
        /// <returns></returns>
        private String isSchemaAlreadyIncluded(String packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemas)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }





        /// <summary>
        /// Is called from extern to append a message to this GUI
        /// </summary>
        /// <param name="type"></param>
        /// <param name="message"></param>
        public void appendMessage(String type, String message, String packageName)
        {
            if (type == "info")
                this.appendInfoMessage(message, packageName);
            else if (type == "warn")
                this.appendWarnMessage(message, packageName);
            else if (type == "error")
                this.appendErrorMessage(message, packageName);

        }

        public String TargetNameSpacePrefix
        {
            get { return targetnameSpacePrefix; }
            set { targetnameSpacePrefix = value; }
        }




        /// <summary>
        /// This methods determins, what should be passed to an auxilliary schema generator
        /// If this class itself has already been called by another class, the calling class is passed
        /// otherwise an instance of this class is passed
        /// </summary>
        /// <returns></returns>
        private GeneratorCallBackInterface getCaller()
        {
            if (this.caller == null)
                return this;
            else
                return caller;
        }

        public static void ValidationCallbackOne(object sender, ValidationEventArgs args)
        {
            throw new XmlSchemaException(args.Message + args.Exception.StackTrace);
        }



        /// <summary>
        /// Return the Annotation for the root schema
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private XmlSchemaAnnotation getRootSchemaAnnotation(EA.Element abie)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();

            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*Name", 
                "*Version", 
                "*Definition", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue" };

            String[] values = { XMLTools.getElementTVValue(CCTS_TV.UniqueID, abie), 
                "RSM", 
                XMLTools.getElementTVValue(CCTS_TV.Name, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Version, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Definition, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.OfficialConstraintContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.ProductContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.IndustryContextValue, abie),
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessContextValue, abie),
                XMLTools.getElementTVValue(CCTS_TV.SupportingRoleContextValue, abie),
                XMLTools.getElementTVValue(CCTS_TV.SystemCapabilitiesContextValue, abie) };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }


        /// <summary>
        /// Search Connector with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the element with type XMLSchemaElement
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </summary>
        /// <returns></returns>
        private void SearchConnectorForPositionTaggedValue(EA.Collection col, ArrayList tempPosition, ArrayList tempNoPosition, XmlSchemaElement elemRef)
        {
            bool isError = false;
            bool isPositionExist = false;


            //search for attribute's tagged value 'position'
            foreach (EA.ConnectorTag tagval in col)
            {
                //if "position" tagged value exist and has value
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != ""))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(elemRef);
                        temp.Add("Connector");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(elemRef.Name);
                temp.Add(elemRef);
                temp.Add("Connector");

                tempNoPosition.Add(temp);
            }
        }



        /// <summary>
        /// Search Attribute with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the attribute with type EA.Attribute
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </summary>
        /// <returns></returns>
        private void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempPosition, ArrayList tempNoPosition)
        {
            bool isError = false;
            bool isPositionExist = false;

            foreach (EA.AttributeTag tagval in attr.TaggedValues)
            {
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != null))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                        break;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(attr);
                        temp.Add("Attribute");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(attr.Name);
                temp.Add(attr);
                temp.Add("Attribute");

                tempNoPosition.Add(temp);
            }
        }

        private void chkNillable_CheckedChanged(object sender, EventArgs e)
        {
            if (chkNillable.Checked == true)
            {
                DialogResult result = MessageBox.Show("CAUTION: The resultant schemas may not be compliant with UN/CEFACT Naming and Design Rules." +
                "\nPlease confirm with your business domain owner before enabling." + "\nAre you sure want to continue?",
                "Warning", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);

                if (result == DialogResult.Yes)
                {
                    chkNillable.Checked = true;
                    blnNillable = true;
                }
                else
                {
                    chkNillable.Checked = false;
                    blnNillable = false;
                }
            }
            else
                chkNillable.Checked = false;
        }

        private void label1_Click(object sender, EventArgs e)
        {
            if (chkNillable.Checked == false)
            {
                DialogResult result = MessageBox.Show("CAUTION: The resultant schemas may not be compliant with UN/CEFACT Naming and Design Rules." +
                "\nPlease confirm with your business domain owner before enabling." + "\nAre you sure want to continue?",
                "Warning", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);

                if (result == DialogResult.Yes)
                {
                    chkNillable.Checked = true;
                    blnNillable = true;
                }
                else
                {
                    chkNillable.Checked = false;
                    blnNillable = false;
                }
            }
            else
                chkNillable.Checked = false;
        }

        private string DeterminePrefix(Package importPackage)
        {
            if (importPackage.Element.Stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                return "udt" + ++countUDTImports;
            else
                if (importPackage.Element.Stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                    return "enum" + ++countENUMImports;
                else
                    if (importPackage.Element.Stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                        return "qdt" + ++countQDTImports;
                    else
                        throw new XMLException("");

            //return "";
        }

    }
}

