/*******************************************************************************
This file is part of the VIENNAAddIn project

Licensed under GNU General Public License V3 http://gplv3.fsf.org/

For further information on the VIENNAAddIn project please visit 
http://vienna-add-in.googlecode.com
*******************************************************************************/
using System;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Xml;
using System.Xml.Schema;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using EA;
using VIENNAAddIn.Utils;
using VIENNAAddIn.Exceptions;
using VIENNAAddIn.constants;


namespace VIENNAAddIn.CCTS
{
    public partial class CCGenerator : Form, GeneratorCallBackInterface
    {
        private static CCGenerator form;
        public static void ShowForm(Repository repository)
        {
            var scope = repository.DetermineScope();
            if (form == null || form.IsDisposed)
            {
                form = new CCGenerator(repository, scope, false);
                form.Show();
            }
            else
            {
                form.resetGenerator(scope);
                form.Select();
                form.Focus();
                form.Show();
            }
        }


        #region Variable
        private Repository repository = null;
        private String scope = "";
        private Boolean annotate = false;
        private bool withGUI = false;
        private GeneratorCallBackInterface caller = null;
        private bool blnNillable = false;
        private bool blnAlias = false;
        private bool blnIncludeLinkedSchema = false;

        //private bool DEBUG;

        //This ArrayList holds a List of all auxilliary schmeas
        //that had to be created for this schema to be valid
        private System.Collections.ArrayList alreadyCreatedSchemas = new ArrayList();

        //This arraylist hold a list of auxilliary schema that generated by BusinessLibraryGenerator
        private ArrayList alreadyCreatedSchemasBLGen = new ArrayList();

        //if generate from anyLevel, its value will be true, otherwise if generated from specific package it will be false;
        private bool isAnyLevelGeneration = false;

        //The path where the schema(s) should be saved
        private String path = "";
        private String targetNameSpacePrefix = "cc";

        ////These variables are used to make a distinction between namespaces of the same type
        static int countQDTImports = 0;
        static int countUDTImports = 0;
        static int countENUMImports = 0;
        static int countBIEImports = 0;
        static int countCCImports = 0;
        
        #endregion

        #region Constructor


        ///// <summary>
        ///// This constructor is made special for any-level schema generation
        ///// </summary>
        ///// <param name="repository"></param>
        ///// <param name="scope"></param>
        ///// <param name="annotate"></param>
        ///// <param name="path"></param>
        ///// <param name="alreadyCreatedSchemaBLGen"></param>
        //public CCGenerator(EA.Repository repository, String scope, bool annotate, bool blnIncludeLinkedSchema, 
        //    bool blnAlias, bool blnNillable, string path, ArrayList alreadyCreatedSchemaBLGen)
        //{
        //    this.repository = repository;
        //    this.scope = scope;
        //    this.annotate = annotate;
        //    this.blnAlias = blnAlias;
        //    this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
        //    this.blnNillable = blnNillable;

        //    ////With GUI
        //    this.withGUI = false;

        //    //this.test = new CommonRoutineCCBIE(repository, scope, annotate, this.blnIncludeLinkedSchema, this.blnAlias, 
        //    //    this.blnNillable, path, alreadyCreatedSchemaBLGen, caller, typeLibraryEnum.CCLibrary.ToString(), true);

        //    //test.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
        //    //test.isAnyLevelGeneration = true;

        //    this.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
        //    this.isAnyLevelGeneration = true;
        //    this.path = path;
        //}

        ////sementara, nyoba pake caller
        //public CCGenerator(EA.Repository repository, String scope, bool annotate, string path, ArrayList alreadyCreatedSchemaBLGen, GeneratorCallBackInterface caller)
        //{
        //    this.repository = repository;
        //    this.scope = scope;
        //    this.annotate = annotate;
        //    this.caller = caller;
        //    ////With GUI
        //    this.withGUI = false;

        //    this.test = new CommonRoutineCCBIE(repository, scope, annotate, path, alreadyCreatedSchemaBLGen,
        //        caller, typeLibraryEnum.CCLibrary.ToString(), true);

        //    test.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
        //    test.isAnyLevelGeneration = true;
        //}

        /// <summary>
        /// Construct a new BIEGenerator
        /// </summary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        public CCGenerator(EA.Repository repository, String scope, bool annotate)
        {
            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            
            ////With GUI
            this.withGUI = true;
            InitializeComponent();
            this.setActivePackageLabel();
            
            //this.test = new CommonRoutineCCBIE(repository, scope, annotate, this, typeLibraryEnum.CCLibrary.ToString());
            //test.isAnyLevelGeneration = false;

            this.isAnyLevelGeneration = false;
        }

        /// <summary>
        /// This Constructor is for linked generation
        /// </summary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        /// <param name="path"></param>
        /// <param name="caller"></param>
        public CCGenerator(EA.Repository repository, String scope, bool annotate, bool blnIncludeLinkedSchema, bool blnAlias,
            bool blnNillable, String path, GeneratorCallBackInterface caller, ArrayList prmAlreadyCreatedSchemasGlobal, bool prmIsAnyLevelGeneration)
        {
           
            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
            this.blnAlias = blnAlias;
            this.blnNillable = blnNillable;
            this.path = path;
            this.caller = caller;
            this.alreadyCreatedSchemasBLGen = prmAlreadyCreatedSchemasGlobal;
            this.isAnyLevelGeneration = prmIsAnyLevelGeneration;

            this.withGUI = false;
        }
        
        #endregion

        #region Implement Interface
        
        /// <summary>
        /// Append an error message to the status box
        /// </summary>
        /// <param name="msg"></param>
        private void appendErrorMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("error", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                {
                    this.statusTextBox.Text += "ERROR: (Package: " + packageName + ") " + msg + "\n\n";
                }
            }
        }
        
        /// <summary>
        /// Show a info message in the status box
        /// </summary>
        /// <param name="msg"></param>
        private void appendInfoMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("info", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                {
                    this.statusTextBox.Text += "INFO: (Package: " + packageName + ") " + msg + "\n\n";
                }
            }
        }
        
        /// <summary>
        /// Show a warn message in the status box
        /// </summary>
        /// <param name="msg"></param>
        private void appendWarnMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("warn", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                    this.statusTextBox.Text += "WARN: (Package: " + packageName + ") " + msg + "\n\n";
            }
        }

        /// <summary>
        /// Is called from extern to append a message to this GUI
        /// </summary>
        /// <param name="type"></param>
        /// <param name="message"></param>
        public void appendMessage(String type, String message, String packageName)
        {
            if (type == "info")
                this.appendInfoMessage(message, packageName);
            else if (type == "warn")
                this.appendWarnMessage(message, packageName);
            else if (type == "error")
                this.appendErrorMessage(message, packageName);

        }
        #endregion

        #region Method for this CC generator
        /// <summary>
        /// Reset Generator
        /// </summary>
        /// <param name="scope"></param>
        public void resetGenerator(String scope)
        {
            this.scope = scope;
            this.alreadyCreatedSchemas = new ArrayList();
            this.progressBar1.Value = this.progressBar1.Minimum;
            this.statusTextBox.Text = "";
            this.setActivePackageLabel();
        }


        /// <summary>
        /// Setze den Text der ausgewählten BIELibrary
        /// </summary>
        private void setActivePackageLabel()
        {
            EA.Package p = this.repository.GetPackageByID(Int32.Parse(this.scope));
            this.selectedBIELibrary.Text = p.Element.Name + "<<" + p.Element.Stereotype.ToString() + ">>";
        }


        /// <summary>
        /// Search for particular webSchemaPath
        /// </summary>
        /// <param name="webSchemaPath">Web address for schema</param>
        /// <param name="pkg">Package</param>
        /// <returns></returns>
        private bool IsSchemaExist(string webSchemaPath, EA.Package pkg)
        {
            foreach (EA.File file in pkg.Element.Files)
            {
                if (file.Name == webSchemaPath)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the name of the current package
        /// </summary>
        /// <returns></returns>
        private String getPackageName()
        {
            return this.repository.GetPackageByID(Int32.Parse(this.scope)).Name.ToString();
        }

        /// <summary>
        /// Performs a step with the progress bar
        /// </summary>
        public void performProgressStep()
        {
            if (this.withGUI)
            {
                this.progressBar1.PerformStep();
            }
            else
            {
                //Is there a caller for this class?
                if (caller != null)
                    caller.performProgressStep();
            }
        }

        private void ValidationCallbackOne(object sender, ValidationEventArgs args)
        {
            throw new XmlSchemaException(args.Message + args.Exception.StackTrace);
        }

        /// <summary>
        /// Generate a schema out of the given ABIEs
        /// </summary>
        /// <param name="p"></param>
        public System.Collections.ICollection generateSchema(EA.Package p)
        {
            //add current package to the list of alreadyCreatedSchema to avoid infinte loop on linked schema
            //coz linked schema could have link to current package
            addCurrentPackageNamespace(p);

            ArrayList rootCollection = new ArrayList();

            ////Validate the BIELibrary first
            //String validationError = new BCSSValidator(this.repository, this.scope).validateBIELibrary();
            //if (validationError != "")
            //{
            //    this.appendErrorMessage(validationError, this.getPackageName());
            //    throw (new XMLException("Nested error. Please see error message above."));
            //}

            XmlSchema schema = new XmlSchema();

            schema.ElementFormDefault = XmlSchemaForm.Qualified;
            schema.AttributeFormDefault = XmlSchemaForm.Unqualified;
            schema.Version = XMLTools.getSchemaVersionFromPackage(p);

            //Add the namespaces necessary for the BIE schema
            //test.addNameSpaces(schema);
            addNameSpaces(schema);

            //Add the import schemas
            //CommonRoutineCCBIE.addImports(schema);

            

            int elementCount = 0;
            //Iterate through the ACCs
            //foreach (EA.Element element in p.Elements)
            for (short indexElement=0; indexElement <p.Elements.Count; indexElement++)
            {
                EA.Element element = (EA.Element)p.Elements.GetAt(indexElement);
                elementCount++;
                if (element.Stereotype.Equals(CCTS_Types.ACC.ToString()))
                {
                    XmlSchemaComplexType el = getSchemaElement(element, schema); //test.getSchemaElement(element, schema);
                    //this.appendInfoMessage("Successfully get schema element " + element.Name, p.Name);
                    if (el != null)
                        schema.Items.Add(el);
                }

                if (XMLTools.getElementTVValue("isRoot", element).Equals("true", StringComparison.OrdinalIgnoreCase))
                    rootCollection.Add(element);

                //After every 20th iteration we  perform one progress step
                if (elementCount % 20 == 0)
                    this.performProgressStep();
            }

            addRootElement(schema, rootCollection);
            
            //Validate the Schema
            XmlSchemaSet xsdSet = new XmlSchemaSet();
            xsdSet.XmlResolver = null;
            xsdSet.ValidationEventHandler += new ValidationEventHandler(ValidationCallbackOne);
            try
            {
                xsdSet.Add(schema);
                //xsdSet.Compile();
            }
            catch (XmlSchemaException xse)
            {
                //MessageBox.Show(xse.Message + "\n" + xse.StackTrace.ToString());                
                throw xse;
            }

            return xsdSet.Schemas();
        }

        /// <summary>
        /// Adds the root element to the schema
        /// </summary>
        /// <param name="schema"></param>
        /// <param name="rootElementID"></param>
        private void addRootElement(XmlSchema schema, ArrayList rootCollection)
        {
            foreach (EA.Element element in rootCollection)
            {
                EA.Element e = this.repository.GetElementByID(element.ElementID);

                XmlSchemaElement rootElement = new XmlSchemaElement();
                rootElement.Name = XMLTools.getXMLName(e.Name);
                rootElement.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(e.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));

                schema.Items.Add(rootElement);
            }
        }

        

        

       

        


        #endregion

        #region Event Handler

        /// <summary>
        /// Generate the Schema
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnGenerateSchema_Click(object sender, EventArgs e)
        {

            resetGenerator(this.scope);

            getCheckedOption();

            

            //if (this.chkIncludeLinkedSchema.Checked)
            //    CC_Utils.blnLinkedSchema = true;
            //else
            //    CC_Utils.blnLinkedSchema = false;

            ////using alias for package's name is prefered.
            //if (chkUseAlias.Checked)
            //    CC_Utils.blnAlias = true;
            //else
            //    CC_Utils.blnAlias = false;

            //if (DEBUG)
            //{
            //    //path = "C:\\Dokumente und Einstellungen\\pliegl\\Desktop\\xsd-schema";
            //}
            //else
            //{
            //First we need to know the path where to save the schema(s)            
            DialogResult dr = this.folderBrowserDialog1.ShowDialog(this);
            if (dr.Equals(DialogResult.Cancel))
            {
                folderBrowserDialog1.Dispose();
                return;
            }

            this.path = this.folderBrowserDialog1.SelectedPath;
            //}

            if (this.path != null && !this.path.Equals(""))
            {

                this.path = this.path + "\\";
                //test.path = this.folderBrowserDialog1.SelectedPath + "\\";

                //Get the active Package
                EA.Package p = this.repository.GetPackageByID(Int32.Parse(this.scope));

                this.performProgressStep();

                String error = "";
                System.Collections.ICollection result = null;

                this.appendInfoMessage("Starting CC schema creation. Please wait.", this.getPackageName());

                try
                {
                    
                    

                    result = generateSchema(p);
                }
                catch (Exception exc)
                {
                    error = exc.Message;
                }

                //Kein Fehler aufgetreten - schreibe das Ergebnis
                if (error == "")
                {
                    string baseURL = XMLTools.getBaseURL(repository, this.scope);
                    foreach (XmlSchema schema in result)
                    {
                        String schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(Int32.Parse(this.scope)), repository, this.blnAlias);
                        String filename = path + schemaPath + XMLTools.getSchemaName(this.repository.GetPackageByID(Int32.Parse(this.scope)));
                        //Create the path
                        System.IO.Directory.CreateDirectory(path + schemaPath);
                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                        schema.Write(outputStream);
                        outputStream.Close();

                        if (baseURL != "")
                        {
                            EA.Package pkg = this.repository.GetPackageByID(Int32.Parse(this.scope));
                            string schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(Int32.Parse(this.scope)));
                            string webSchemaPath = baseURL + "/" + schemaPath.Replace("\\", "/") + schemaName;

                            //add the address to property of package
                            if (!IsSchemaExist(webSchemaPath, pkg))
                            {
                                EA.File myfile = (EA.File)pkg.Element.Files.AddNew(webSchemaPath, "Web Address");

                                myfile.Update();
                                pkg.Element.Files.Refresh();
                            }
                        }
                    }
                    this.appendInfoMessage("The schema was created successfully.", this.getPackageName());
                }
                else
                {
                    this.appendErrorMessage(error, this.getPackageName());
                }

                this.progressBar1.Value = this.progressBar1.Maximum;
            }
            else
            {
                this.appendErrorMessage("Plese select a location for the generated schemas first.", this.getPackageName());
            }
        }


        ///// <summary>
        ///// Cancel Button
        ///// </summary>
        ///// <param name="sender"></param>
        ///// <param name="e"></param>
        private void btnCancel_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        public void chkNillable_CheckedChanged(object sender, EventArgs e)
        {
            if (chkNillable.Checked == true)
            {
                DialogResult result = MessageBox.Show("CAUTION: The resultant schemas may not be compliant with UN/CEFACT Naming and Design Rules." +
                "\nPlease confirm with your business domain owner before enabling." + "\nAre you sure want to continue?",
                "Warning", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);

                if (result == DialogResult.Yes)
                {
                    chkNillable.Checked = true;
                    //test.blnNillable = true;
                    this.blnNillable = true;
                }
                else
                {
                    chkNillable.Checked = false;
                    //test.blnNillable = false;
                    this.blnNillable = false;
                }
            }
            else
                chkNillable.Checked = false;
        }

        #endregion



        #region kelas gabungan
        /// <summary>
        /// Creates a Schema Element for the passed EA.Element
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        internal XmlSchemaComplexType getSchemaElement(EA.Element e, XmlSchema schema)
        {


            //Create an new ComplexType for the passed ABIE
            XmlSchemaComplexType complexType = new XmlSchemaComplexType();
            complexType.Name = XMLTools.getXMLName(e.Name) + "Type";
            XmlSchemaSequence sequence = new XmlSchemaSequence();

            if (!XMLTools.isElementAlreadyIncludedInSchema(schema, complexType.Name))
            {

                //Get the annotation
                if (this.annotate)
                    complexType.Annotation = getABIEAnnotation(e);

                #region get attribute

                ArrayList tempPostion = new ArrayList();
                ArrayList tempNoPostion = new ArrayList();

                foreach (EA.Attribute attr in e.Attributes)
                {
                    SearchAttributeForPositionTaggedValue(attr, tempPostion, tempNoPostion);
                }

                #endregion

                #region get aggregation

                //Now check, whether there are any ASBIEs
                //foreach (EA.Connector con in e.Connectors)
                for (short index=0; index < e.Connectors.Count; index++)
                {
                    EA.Connector con = (EA.Connector)e.Connectors.GetAt(index);
                    if (con.Type == EA_Element.Aggregation.ToString() && con.Stereotype.ToString() == CCTS_Types.ASCC.ToString()
                        && con.SupplierID == e.ElementID)
                    {
                        //Elements within the BIE library may have connectors which lead to DOCLibraries
                        //(because BIEs are used within DOCLibraries)
                        //Ignore such connectors                    
                        EA.ConnectorEnd clientEnd = con.ClientEnd;
                        EA.Element client = this.repository.GetElementByID(con.ClientID);
                        EA.Element supplier = this.repository.GetElementByID(con.SupplierID);

                        //Is the connection type an Aggregation or a Composition?
                        //A composition == 2
                        bool isComposition = false;
                        if (con.SupplierEnd.Aggregation == 2)
                        {
                            isComposition = true;
                        }
                        String elementName = "";

                        //If a role name is specified, we take the name of the
                        //role and create a new element from it (if it does not already exist)
                        //If a role name is specified, the name is
                        //Supplier.Name + Role.Name + Client.Name
                        if (clientEnd.Role != "")
                        {
                            elementName = XMLTools.getXMLName(clientEnd.Role + client.Name);
                        }
                        else
                        {
                            //If no role name is specified, the name is
                            //Supplier.Name + Client.Name
                            elementName = XMLTools.getXMLName(client.Name);
                        }


                        if (isInSamePackage(client))
                        {
                            //if (!isComposition) {
                            //    if (!XMLTools.isElementAlreadyIncludedInSchema(schema, elementName)) {
                            //        //We need to create a new element
                            //        XmlSchemaElement xel = new XmlSchemaElement();
                            //        xel.Name = elementName;
                            //        xel.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //        schema.Items.Add(xel);
                            //    }
                            //}

                            //Now add a reference to this element to the sequence
                            XmlSchemaElement elemRef = new XmlSchemaElement();

                            //Annotate?
                            if (this.annotate)
                                elemRef.Annotation = getASBIEAnnotation(con);

                            ////Set the cardinality of the element
                            setASBIECardinality(elemRef, clientEnd.Cardinality);

                            //If the association is a composition we have to declare the ASBIE
                            //locally

                            //aggregation or composition is treated the same way - for quick fix
                            //if (isComposition) {
                            elemRef.Name = elementName;
                            elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //}
                            //else {
                            //    elemRef.RefName = new XmlQualifiedName(elementName, XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //}

                            #region search for 'position' tagged value
                            //aggregation or composition is treated the same way - for quick fix
                            //if (isComposition)
                            SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

                            #endregion

                        }
                        //Not from this BIELibrary
                        else
                        {
                            
                            //We only import other elements if they are located in a BIELibrary or CCLibrary
                            EA.Package p = this.repository.GetPackageByID(client.PackageID);
                            //this.appendInfoMessage("Get another schema from " + p.Name, "");
                            if (p.Element.Stereotype.Equals(CCTS_Types.BIELibrary.ToString()) || p.Element.Stereotype.Equals(CCTS_Types.CCLibrary.ToString()))
                            {

                                XmlQualifiedName qName = createAndImportAuxilliarySchema(client, schema);
                                XmlSchemaElement elemRef = new XmlSchemaElement();
                                //Annotate?
                                if (this.annotate)
                                    elemRef.Annotation = getASBIEAnnotation(con);

                                ////Set the cardinality of the element
                                setASBIECardinality(elemRef, clientEnd.Cardinality);

                                //If the association is a composition we have to declare the ASBIE
                                //locally
                                //aggregation or composition is treated the same way - for quick fix
                                //if (isComposition) {
                                elemRef.Name = elementName;
                                elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(client.PackageID)));
                                //}
                                //else {
                                //    elemRef.RefName = qName;
                                //}

                                #region search for 'position' tagged value
                                //aggregation or composition is treated the same way - for quick fix
                                //if (isComposition)
                                SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

                                #endregion

                            }
                        }
                    }
                }

                #endregion

                #region Sort the BBIE and ASBIE
                //sort connector, then insert it into sequence
                SortByPosition comparerPosition = new SortByPosition();
                SortByName comparerName = new SortByName();

                tempPostion.Sort(comparerPosition);
                tempNoPostion.Sort(comparerName);

                //sort the element with "position" tagged value
                //foreach (object obj in tempPostion)
                for(short indexObject=0; indexObject<tempPostion.Count; indexObject++)
                {
                    object obj = tempPostion[indexObject];
                    if (((ArrayList)obj)[2].ToString() == "Attribute")
                    {
                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                        if (attribute.Stereotype.Equals(CCTS_Types.BCC.ToString()))
                        {
                            XmlSchemaElement attrElem = new XmlSchemaElement();
                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
                            //Set the type
                            setBBIEType(attrElem, attribute, schema, e);
                            //Set the cardinality
                            setBBIECardinality(attrElem, attribute);
                            //Get the annotation
                            if (this.annotate)
                                attrElem.Annotation = getBBIEAnnotation(attribute);
                            //check for lower cardinality, if lower bound = 0, add nillable attribute
                            if (getCaller().GetType() == typeof(DOCGenerator))
                            {
                                DOCGenerator theCaller = (DOCGenerator)getCaller();
                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }
                            else
                            {
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }

                            //Add the element to the sequence
                            sequence.Items.Add(attrElem);
                        }
                    }
                    else if (((ArrayList)obj)[2].ToString() == "Connector")
                    {
                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                        sequence.Items.Add(schemaElement);
                    }

                }

                //sort the element alphabetically
                //foreach (object obj in tempNoPostion)
                for (short indexObject = 0; indexObject < tempNoPostion.Count; indexObject++)
                {
                    object obj = tempNoPostion[indexObject];
                    if (((ArrayList)obj)[2].ToString() == "Attribute")
                    {
                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                        if (attribute.Stereotype.Equals(CCTS_Types.BCC.ToString()))
                        {
                            XmlSchemaElement attrElem = new XmlSchemaElement();
                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
                            //Set the type
                            setBBIEType(attrElem, attribute, schema, e);
                            //Set the cardinality
                            setBBIECardinality(attrElem, attribute);
                            //Get the annotation
                            if (this.annotate)
                                attrElem.Annotation = getBBIEAnnotation(attribute);

                            //check for lower cardinality, if lower bound = 0, add nillable attribute
                            if (getCaller().GetType() == typeof(DOCGenerator))
                            {
                                DOCGenerator theCaller = (DOCGenerator)getCaller();
                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }
                            else
                            {
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }

                            //Add the element to the sequence
                            sequence.Items.Add(attrElem);
                        }
                    }
                    else if (((ArrayList)obj)[2].ToString() == "Connector")
                    {
                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                        sequence.Items.Add(schemaElement);
                    }
                }

                //generate warning if there is a mix sort, alphabetically and sequence
                if ((tempPostion.Count > 0) && (tempNoPostion.Count > 0))
                    this.appendWarnMessage("There is a mix of sequence and alphabetic sorting of attributes (BBIEs) and aggregations (ASBIEs)" + e.Name, this.getPackageName());

                #endregion
            }

            complexType.Particle = sequence;

            return complexType;

        }

        /// <summary>
        /// Search Connector with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the element with type XMLSchemaElement
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </summary>
        /// <returns></returns>
        private void SearchConnectorForPositionTaggedValue(EA.Collection col, ArrayList tempPosition, ArrayList tempNoPosition, XmlSchemaElement elemRef)
        {
            bool isError = false;
            bool isPositionExist = false;


            //search for attribute's tagged value 'position'
            foreach (EA.ConnectorTag tagval in col)
            {
                //if "position" tagged value exist and has value
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != ""))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(elemRef);
                        temp.Add("Connector");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(elemRef.Name);
                temp.Add(elemRef);
                temp.Add("Connector");

                tempNoPosition.Add(temp);
            }
        }

        /// <summary>
        /// Search Attribute with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the attribute with type EA.Attribute
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </summary>
        /// <returns></returns>
        //private  void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempAttr, ArrayList tempAttrWithPosition)
        private void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempPosition, ArrayList tempNoPosition)
        {
            bool isError = false;
            bool isPositionExist = false;

            foreach (EA.AttributeTag tagval in attr.TaggedValues)
            {
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != null))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                        break;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(attr);
                        temp.Add("Attribute");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(attr.Name);
                temp.Add(attr);
                temp.Add("Attribute");

                tempNoPosition.Add(temp);
            }
        }


        private XmlQualifiedName createAndImportAuxilliarySchema(EA.Element e, XmlSchema schema)
        {
            //Get the package of origin of the element
            EA.Package p = this.repository.GetPackageByID(e.PackageID);
            String pName = p.Name;
            String s = "";

            //if the generation is from any level generation
            //if (isAnyLevelGeneration)
            //{
                String sBLGen = "";
                //is the schema already included in global array?
                if ((s = isSchemaAlreadyIncluded(p.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(p.Name)) != "")
                {
                    #region for any level package generation, to check if there was previously generated schema
                    ////We need to add an import statement for the newly generated schema
                    ////to the original schema
                    ////if (different package than previously generated) and !(already included)

                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();

                    //String schemaPath = "";
                    String schemaName = "";
                    //schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository);
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
                    //String filename = path + schemaPath + schemaName;


                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnAlias);//CC_Utils.blnAlias);

                    determineImportOrInclude(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;

                    //add the schema to local alreadyCreatedSchema
                    this.alreadyCreatedSchemas.Add(aux);
                    #endregion
                }
            //}

            //Is this schema already included?
            if ((s = isSchemaAlreadyIncluded(p.Name)) == "")
            {
                if (!this.blnIncludeLinkedSchema)//CC_Utils.blnLinkedSchema)
                {
                    #region Include linked schema unchecked - for particular generation only
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();
                    this.alreadyCreatedSchemas.Add(aux);

                    String schemaName = "";
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));

                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnAlias);

                    addImport(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;
                    #endregion
                }
                else
                {
                    #region Include linked schema checked

                    System.Collections.ICollection result = null;

                    if (p.Element.Stereotype == CCTS_Types.BIELibrary.ToString())
                    {
                        //if (this.isAnyLevelGeneration)
                        //{
                        //    result = new BIEGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                        //        this.blnAlias, this.blnNillable, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
                        //}
                        //else
                        //{
                            result = new BIEGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                                this.blnAlias, this.blnNillable, this.path, getCaller(), this.alreadyCreatedSchemasBLGen, this.isAnyLevelGeneration).generateSchema(p);
                        //}
                    }
                    else if (p.Element.Stereotype == CCTS_Types.CCLibrary.ToString())
                    {
                        //if (this.isAnyLevelGeneration)
                        //{
                        //    result = new CCGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                        //        this.blnAlias, this.blnNillable, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
                        //}
                        //else
                        //{
                            result = new CCGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                            this.blnAlias, this.blnNillable, this.path, getCaller(), this.alreadyCreatedSchemasBLGen, this.isAnyLevelGeneration).generateSchema(p);
                        //}
                    }
                    //Create an Auxilliary schema and store it in the collection - later we have to
                    //add it to the main schema collection
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    //if (this.typeLibrary == typeLibraryEnum.BIELibrary.ToString())
                    //    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    //else
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "cc" + ++countBIEImports);

                    aux.PackageOfOrigin = p.Name.ToString();
                    aux.Schemas = result;

                    this.alreadyCreatedSchemas.Add(aux);

                    //if (isAnyLevelGeneration)
                        this.alreadyCreatedSchemasBLGen.Add(aux);


                    String schemaPath = "";
                    String schemaName = "";
                    schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository, this.blnAlias);
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
                    String filename = path + schemaPath + schemaName;

                    //Write the schema(s)
                    foreach (XmlSchema schema1 in result)
                    {
                        //Create the path
                        System.IO.Directory.CreateDirectory(path + schemaPath);
                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                        schema1.Write(outputStream);
                        outputStream.Close();
                    }

                    //We need to add an import statement for the newly generated schema
                    //to the original schema
                    String importPath = XMLTools.getImportPathForSchema(p, repository, schemaName, scope, this.blnAlias);

                    //check whether it's "include" or "import"
                    determineImportOrInclude(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;

                    #endregion
                }
            }

            return new XmlQualifiedName(e.Name + "Type", s);

        }

        private void determineImportOrInclude(XmlSchema schema, String schemaLocation, String namespace_)
        {
            if (schema.TargetNamespace == namespace_)
                addInclude(schema, schemaLocation, namespace_);
            else
                addImport(schema, schemaLocation, namespace_);
        }

        /// <summary>
        /// Return the Annotation for a given ASBIE element
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        internal XmlSchemaAnnotation getASBIEAnnotation(EA.Connector con)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();

            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*Cardinality", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*PropertyTerm", 
                "*PropertyQualifierTerm", 
                "*AssociatedObjectClassTerm", 
                "*AssociatedObjectClassQualifierTerm", 
                "*AssociationType", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm",     
                "*Example",
                "*RepresentationLayout" //,
                //"*Notes"
            };

            String[] values = { XMLTools.getConnectorTVValue(CCTS_TV.UniqueID,con), 
                "ASCC", 
                XMLTools.getConnectorTVValue(CCTS_TV.DictionaryEntryName,con), 
                XMLTools.getConnectorTVValue(CCTS_TV.Version,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.Definition,con), 
                getASBIECardinality(con.ClientEnd), 
                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassQualifierTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.PropertyTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.PropertyQualifierTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassQualifierTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.AssociationType,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.GeopoliticalOrRegionContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.OfficialConstraintContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.ProductContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.IndustryContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.SupportingRoleContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.SystemCapabilitiesContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.UsageRule,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.Example,con),
                XMLTools.getConnectorTVValue(CCTS_TV.RepresentationLayout,con)//,
                //con.Notes
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }


        /// <summary>
        /// Return the ASBIE Cardinality
        /// </summary>
        /// <param name="clientEnd"></param>
        /// <returns></returns>
        private String getASBIECardinality(EA.ConnectorEnd clientEnd)
        {

            if (clientEnd.Cardinality == "")
                return "1";
            else
                return clientEnd.Cardinality;
        }


        /// <summary>
        /// Sets the cardinality of the element according to the information in the 
        /// AggregateBusinessInformationEntity
        /// This proves to be a little bit more tricky than with the BCC because we
        /// receive only one String containing both, the upper and the lower bound
        /// </summary>
        /// <param name="e1"></param>
        /// <param name="abie"></param>
        internal void setASBIECardinality(XmlSchemaElement e1, String c)
        {

            String lower = "";
            String upper = "";
            try
            {
                //Try to split up the String
                String cardinality = c;
                lower = cardinality.Substring(0, 1);
                upper = cardinality.Substring(3);
            }
            catch { }

            try
            {
                //Try to set the lower
                int i = Int32.Parse(lower);
                e1.MinOccurs = i;
            }
            catch { }

            try
            {
                //Try to set the upper
                if (upper == "*")
                    e1.MaxOccursString = "unbounded";
                else
                {
                    int i = Int32.Parse(upper);
                    if (i != 1)
                        e1.MaxOccurs = i;
                }
            }
            catch { }

        }


        /// <summary>
        /// Return the Annotation for a given ABIE element
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        private XmlSchemaAnnotation getABIEAnnotation(EA.Element abie)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();
            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm", 
                "*Example",
                "*RepresentationLayout"//,
                //"*Notes"
            };

            //Get ObjectClassTerm & ObjectClassQualifierTerm
            string[] objClassTerm = GetObjectClassTerm(abie);

            String[] values = { XMLTools.getElementTVValue(CCTS_TV.UniqueID, abie), 
                "ACC", 
                XMLTools.getElementTVValue(CCTS_TV.DictionaryEntryName, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Version, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Definition, abie),
                objClassTerm[1] != null ? objClassTerm[1] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassTerm, abie), 
                objClassTerm[0] != null ? objClassTerm[0] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassQualifierTerm, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, abie),                  
                XMLTools.getElementTVValue(CCTS_TV.OfficialConstraintContextValue, abie),                
                XMLTools.getElementTVValue(CCTS_TV.ProductContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.IndustryContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessRoleContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.SupportingRoleContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.SystemCapabilitiesContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.UsageRule, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessTerm, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Example, abie),
                XMLTools.getElementTVValue(CCTS_TV.RepresentationLayout, abie)//,
                //abie.Notes
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }

        private string[] GetObjectClassTerm(Element abie)
        {
            string[] objClassTerm = new string[2];
            foreach (EA.TaggedValue tg in abie.TaggedValues)
            {
                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
                {
                    string dict = tg.Value;
                    string[] partsOfDEN = null;

                    //split the Dictionary Entry Name into three part
                    for (int i = 1; i < 4; i++)
                    {
                        partsOfDEN = dict.Split(".".ToCharArray(), i);
                    }

                    string[] splitFirstPart = null;
                    //split the first part of DEN
                    for (int i = 1; i < 3; i++)
                    {
                        splitFirstPart = partsOfDEN[0].Split("_".ToCharArray(), i);
                    }
                    if (splitFirstPart.GetUpperBound(0) == 1)  // "object class term qualifier" is exist
                    {
                        objClassTerm[0] = splitFirstPart[0]; //object class term qualifier
                        objClassTerm[1] = splitFirstPart[1]; //Object Class Term
                    }
                    else
                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term

                    break;
                }
            }
            return objClassTerm;
        }


        /// <summary>
        /// Return the Annotation for a given BBIE element
        /// </summary>
        /// <returns></returns>
        internal XmlSchemaAnnotation getBBIEAnnotation(EA.Attribute bcc)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();

            String card = bcc.LowerBound + ".." + bcc.UpperBound;
            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*Cardinality", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*PropertyTerm", 
                "*PropertyQualifierTerm", 
                "*PrimaryRepresentationTerm", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm", 
                "*Example",
                "*RepresentationLayout"//,
                //"*Notes"
            };

            //Get ObjectClassTerm & ObjectClassQualifierTerm
            string[] objClassTerm = GetObjectClassTermBBIE(bcc);

            String[] values = { XMLTools.getAttributeTVValue(CCTS_TV.UniqueID, bcc), 
                CCTS_Types.BCC.ToString(), 
                XMLTools.getAttributeTVValue(CCTS_TV.DictionaryEntryName, bcc), 
                XMLTools.getAttributeTVValue(CCTS_TV.Version, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.Definition, bcc), 
                card, 
                objClassTerm != null ? (objClassTerm[1] != null ? objClassTerm[1] : "") : "" ,//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassTerm, bbie), 
                objClassTerm != null ? (objClassTerm[0] != null ? objClassTerm[0] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassQualifierTerm, bbie), 
                objClassTerm != null ? (objClassTerm[3] != null ? objClassTerm[3] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyTerm, bbie), 
                objClassTerm != null ? (objClassTerm[2] != null ? objClassTerm[2] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyQualifierTerm, bbie),
                objClassTerm != null ? (objClassTerm[4] != null ? objClassTerm[4] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PrimaryRepresentationTerm, bbie),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.OfficialConstraintContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.ProductContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.IndustryContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.SupportingRoleContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.SystemCapabilitiesContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.UsageRule, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessTerm, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.Example, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.RepresentationLayout, bcc)//,
                //bbie.Notes
                
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }

        private string[] GetObjectClassTermBBIE(EA.Attribute bbie)
        {
            string[] objClassTerm = new string[6];
            foreach (EA.AttributeTag tg in bbie.TaggedValues)
            {
                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
                {
                    string dict = tg.Value;
                    string[] partsOfDEN = null;

                    //split the Dictionary Entry Name into three part
                    for (int i = 1; i < 4; i++)
                    {
                        partsOfDEN = dict.Split(".".ToCharArray(), i);
                    }

                    if (partsOfDEN.GetUpperBound(0) != 2)  //if the DEN doesn't have correct parts. The correct DEN must have 3 parts.
                        return null;

                    //split first part of DEN
                    string[] splitFirstPart = null;
                    splitFirstPart = SplitDEN(partsOfDEN[0]);

                    if (splitFirstPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitFirstPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitFirstPart.GetUpperBound(0) - 1))
                                qualifier += splitFirstPart[a];
                            else
                                qualifier += splitFirstPart[a] + "_";
                        }
                        objClassTerm[0] = qualifier; //object class term qualifier
                        objClassTerm[1] = splitFirstPart[splitFirstPart.GetUpperBound(0)]; //Object Class Term
                    }
                    else
                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term


                    //split second part of DEN
                    string[] splitSecondPart = null;
                    splitSecondPart = SplitDEN(partsOfDEN[1]);

                    if (splitSecondPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitSecondPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitSecondPart.GetUpperBound(0) - 1))
                                qualifier += splitSecondPart[a];
                            else
                                qualifier += splitSecondPart[a] + "_";
                        }
                        objClassTerm[2] = qualifier; //property term qualifier
                        objClassTerm[3] = splitSecondPart[splitSecondPart.GetUpperBound(0)]; //Property Term
                    }
                    else
                        objClassTerm[2] = partsOfDEN[1]; //Object Class Term

                    //split third part of DEN
                    string[] splitThirdPart = null;
                    splitThirdPart = SplitDEN(partsOfDEN[2]);

                    if (splitThirdPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitThirdPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitThirdPart.GetUpperBound(0) - 1))
                                qualifier += splitThirdPart[a];
                            else
                                qualifier += splitThirdPart[a] + "_";
                        }
                        objClassTerm[4] = qualifier; //Associated Object Class Term Qualifier
                        objClassTerm[5] = splitThirdPart[splitThirdPart.GetUpperBound(0)]; //Associated Object Class Term
                    }
                    else
                        objClassTerm[4] = partsOfDEN[2]; //Representation Term


                    ////split the third part of DEN
                    //string[] splitThirdPart = null;
                    //for (int i = 1; i < 3; i++)
                    //{
                    //    splitThirdPart = partsOfDEN[2].Split("_".ToCharArray(), i);
                    //}
                    //if (splitThirdPart.GetUpperBound(0) == 1)  // "property term qualifier" is exist
                    //{
                    //    objClassTerm[2] = splitThirdPart[0]; //property term qualifier
                    //    objClassTerm[3] = splitThirdPart[1]; //Property Term
                    //}
                    //else
                    //    objClassTerm[2] = partsOfDEN[2]; //Property Term

                    ////Representation Term
                    //objClassTerm[4] = partsOfDEN[1]; // second part of DEN
                    break;
                }
            }
            return objClassTerm;
        }


        private string[] SplitDEN(string dictEntryName)
        {
            string[] splitFirstPart = null;
            string temp = dictEntryName;
            int count = 1;
            //as long the string still contain "_", we split it.
            do
            {
                splitFirstPart = dictEntryName.Split("_".ToCharArray(), count); //split optional qualifier "_" from first part of ASBIE (target Name)
                temp = splitFirstPart[count - 1];
                count++;
            } while (temp.Contains("_"));

            return splitFirstPart;
        }


        /// <summary>
        /// Sets the cardinality of the element according to the information in the 
        /// BasicBusinessInformationEntity
        /// </summary>
        /// <param name="e1"></param>
        /// <param name="abie"></param>
        private void setBBIECardinality(XmlSchemaElement e1, EA.Attribute bbie)
        {

            //Set Lower Bound            
            try
            {
                int lower = Int32.Parse(bbie.LowerBound);
                e1.MinOccurs = lower;
            }
            catch (Exception e) { }

            //Set Upper Bound
            try
            {
                if (bbie.UpperBound == "*")
                {
                    e1.MaxOccursString = "unbounded";
                }
                else
                {
                    int upper = Int32.Parse(bbie.UpperBound);
                    //We do not need to consider 1 as this is the default value
                    if (upper != 1)
                        e1.MaxOccurs = upper;
                }
            }
            catch (Exception e) { }
        }



        /// <summary>
        /// Sets the type of the given bbie
        /// If the type refers to a cdt/qdt the method first checks,
        /// whether the relevant schema does already exist
        /// If not the schema is created and a reference via import statement
        /// is made
        /// </summary>
        /// <param name="e"></param>
        /// <param name="bbie"></param>
        private void setBBIEType(XmlSchemaElement e, EA.Attribute bbie, XmlSchema schema, EA.Element element)
        {
            try
            {

                String type = bbie.Type;
                int classifierID = bbie.ClassifierID;
                if (classifierID == 0)
                {
                    throw new Exception("Can't find classifier ID for <<" + CCTS_Types.BCC.ToString() + ">>" + bbie.Name
                        + " of <<" + CCTS_Types.ACC.ToString() + ">>" + element.Name);
                }

                EA.Element classifierElement = this.repository.GetElementByID(classifierID);
                EA.Package classifierPackage = this.repository.GetPackageByID(classifierElement.PackageID);
                String stereotype = classifierPackage.Element.Stereotype;
                String s = "";

                //if the generation is from any level generation
                //if (isAnyLevelGeneration)
                //{
                    String sBLGen = "";
                    if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(classifierPackage.Name)) != "")
                    {
                        #region for any level package generation, to check if there was previously generated schema
                        ////We need to add an import statement for the newly generated schema
                        ////to the original schema

                        AuxilliarySchema aux = new AuxilliarySchema();
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));//"cc" + ++countBIEImports);
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();

                        String schemaName = "";
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnAlias);

                        determineImportOrInclude(schema, importPath, aux.Namespace);

                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;

                        //add the schema to local alreadyCreatedSchema
                        this.alreadyCreatedSchemas.Add(aux);
                        #endregion
                    }
                //}

                //Is this schema already included in local array?
                if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "")
                {
                    if (!this.blnIncludeLinkedSchema) //CC_Utils.blnLinkedSchema)
                    {
                        #region "Include linked schema unchecked - for local generation only"
                        ////PRIMLibrary, how to handle?? 25 Sept 08
                        if (!(classifierPackage.Element.Stereotype == CCTS_Types.ENUMLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.DOCLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.CDTLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.QDTLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.BIELibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.CCLibrary.ToString()
                            ))
                        {
                            throw new XMLException("Schema generation from package with stereotype " + stereotype + " is not supported.");
                        }

                        AuxilliarySchema aux = new AuxilliarySchema();
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
                        this.alreadyCreatedSchemas.Add(aux);

                        String schemaName = "";
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnAlias);

                        determineImportOrInclude(schema, importPath, aux.Namespace);

                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;
                        #endregion
                    }
                    else
                    {
                        #region Included linked schema
                        //Create an Auxilliary schema and store it in the collection - later we have to
                        //add it to the main schema collection
                        AuxilliarySchema aux = new AuxilliarySchema();
                        System.Collections.ICollection result = null;

                        if (stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                        {
                            result = new CDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "udt" + ++countUDTImports);
                        }
                        else if (stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                        {
                            if (this.isAnyLevelGeneration)
                            {
                                //result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.blnAlias,
                                    this.blnIncludeLinkedSchema, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                            }
                            else
                            {
                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, 
                                    this.blnIncludeLinkedSchema, this.blnAlias, this.path, getCaller()).generateSchema(classifierPackage);
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                            }
                        }
                        else if (stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                        {
                            result = new ENUMGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "enum" + ++countENUMImports);
                        }
                        else
                        {
                            throw new XMLException("Schema generation from package with stereotype " + stereotype + " is not supported.");
                        }

                        //We get the namespace for the newly created QDTLibrary-Schema from the package name
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
                        aux.Schemas = result;

                        //Add the name of the already-generated schema to local array
                        this.alreadyCreatedSchemas.Add(aux);

                        //Add the name of the already-generated schema to global array for any-level generation
                        //if (isAnyLevelGeneration)
                            this.alreadyCreatedSchemasBLGen.Add(aux);

                        String schemaPath = "";
                        String schemaName = "";
                        schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, this.blnAlias);
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        //Write the schema(s)
                        foreach (XmlSchema schema1 in result)
                        {
                            //It is possible, that more than one schema is returned here (because the
                            //auxilliary schemas may have interdependencies
                            //write only the one where the namespace fits to the one we initally created
                            if (schema1.TargetNamespace.Equals(aux.Namespace))
                            {
                                String filename = path + schemaPath + schemaName;
                                //Create the path
                                System.IO.Directory.CreateDirectory(path + schemaPath);
                                Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                                schema1.Write(outputStream);
                                outputStream.Close();
                            }
                        }

                        //We need to add an import statement for the newly generated schema
                        //to the original schema
                        String importPath = XMLTools.getImportPathForSchema(classifierPackage, repository, schemaName, scope, this.blnAlias);
                        determineImportOrInclude(schema, importPath, aux.Namespace);
                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);
                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;
                        #endregion
                    }
                }
                
                e.SchemaTypeName = new XmlQualifiedName(bbie.Type + "Type", s);


            }
            catch (Exception ex)
            {
                this.appendWarnMessage("Unable to determine correct datatype for attribute " + bbie.Name + " in element " + element.Name + " caused by this error : " + ex.Message + "\n Taking xsd:string instead. ", this.getPackageName());
                e.SchemaTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
            }


        }


        /// <summary>
        /// Returns an empty String if the schema is not included
        /// If the schema is included, the namespace is returned
        /// </summary>
        /// <param name="packageName"></param>
        /// <returns></returns>
        private String isSchemaAlreadyIncluded(String packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemas)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }



        /// <summary>
        /// Add a new import to the schema
        /// </summary>
        /// <param name="schema"></param>
        internal void addImport(XmlSchema schema, String schemaLocation, String namespace_)
        {
            XmlSchemaImport xsi1 = new XmlSchemaImport();
            xsi1.SchemaLocation = schemaLocation;
            xsi1.Namespace = namespace_;
            schema.Includes.Add(xsi1);
        }

        /// <summary>
        /// Add a new import to the schema
        /// </summary>
        /// <param name="schema"></param>
        internal void addInclude(XmlSchema schema, String schemaLocation, String namespace_)
        {
            XmlSchemaInclude xsi1 = new XmlSchemaInclude();
            xsi1.SchemaLocation = schemaLocation;
            //xsi1.Namespaces. = namespace_;
            schema.Includes.Add(xsi1);
        }




        /// <summary>
        /// Adds the necessary Namespaces to the Schema
        /// </summary>
        /// <param name="schema"></param>
        internal void addNameSpaces(XmlSchema schema)
        {
            string schemaNamespace = "";

            schema.Namespaces.Add("xsd", "http://www.w3.org/2001/XMLSchema");
            schema.Namespaces.Add("ccts", "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");

            //Catch if the baseURN tagged value is empty
            schemaNamespace = XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope)));
            if (schemaNamespace == "")
                throw new Exception("Please fill the 'baseURN' tagged value of the package. 'baseURN' tagged value can not be empty.");

            schema.Namespaces.Add(XMLTools.getNameSpacePrefix(this.repository.GetPackageByID(Int32.Parse(this.scope)), this.TargetNameSpacePrefix), schemaNamespace);
            schema.TargetNamespace = schemaNamespace;
        }


        /// <summary>
        /// Checks whether the passed element is in the same package as the acutal package we are operating on
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        private bool isInSamePackage(EA.Element e)
        {
            if (Int32.Parse(scope) == e.PackageID)
                return true;
            else
                return false;
        }

        /// <summary>
        /// This methods determins, what should be passed to an auxilliary schema generator
        /// If this class itself has already been called by another class, the calling class is passed
        /// otherwise an instance of this class is passed
        /// </summary>
        /// <returns></returns>
        private GeneratorCallBackInterface getCaller()
        {
            if (this.caller == null)
                return this;
            else
                return caller;
        }


        private String TargetNameSpacePrefix
        {
            get { return targetNameSpacePrefix; }
            set { targetNameSpacePrefix = value; }
        }

        private string isAlreadyInBLGenArray(string packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemasBLGen)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }

        private string DeterminePrefix(Package importPackage)
        {
            if (importPackage.Element.Stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                return "udt" + ++countUDTImports;
            else
                if (importPackage.Element.Stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                    return "enum" + ++countENUMImports;
                else
                    if (importPackage.Element.Stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                        return "qdt" + ++countQDTImports;
                    else
                        if (importPackage.Element.Stereotype.Equals(CCTS_Types.CCLibrary.ToString()))
                            return "cc" + ++countCCImports; // not sure on this prefix :-?
                        else
                            throw new XMLException("Can't determine prefix from package " + importPackage.Name);

            //return "";
        }

        private void getCheckedOption()
        {
            if (this.annotateElementBox.Checked)
            {
                this.annotate = true;
                //test.annotate = true;
            }
            else
            {
                this.annotate = false;
                //test.annotate = false;
            }

            if (this.chkIncludeLinkedSchema.Checked)
            {
                this.blnIncludeLinkedSchema = true;
                //test.blnIncludeLinkedSchema = true;
            }
            else
            {
                this.blnIncludeLinkedSchema = false;
                //test.blnIncludeLinkedSchema = false;
            }

            if (this.chkUseAlias.Checked)
            {
                this.blnAlias = true;
                //test.blnAlias = true;
            }
            else
            {
                this.blnAlias = false;
                //test.blnAlias = false;
            }

            if (this.chkNillable.Checked)
            {
                this.blnNillable = true;
                //test.blnNillable = true;
            }
            else
            {
                this.blnNillable = false;
                //test.blnNillable = false;
            }
        }

        /// <summary>
        /// add current package to the list of alreadyCreatedSchema to avoid infinte loop on linked schema
        /// coz linked schema could have link to current package
        /// </summary>
        /// <param name="package"></param>
        private void addCurrentPackageNamespace(EA.Package package)
        {
            AuxilliarySchema aux = new AuxilliarySchema();
            aux.Namespace = XMLTools.getNameSpace(this.repository, package);
            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(package, DeterminePrefix(package));//"cc" + ++countBIEImports);
            aux.PackageOfOrigin = package.Name.ToString();
            this.alreadyCreatedSchemasBLGen.Add(aux);
        }
        #endregion
    }
}