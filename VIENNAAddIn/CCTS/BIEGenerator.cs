/*******************************************************************************
This file is part of the VIENNAAddIn project

Licensed under GNU General Public License V3 http://gplv3.fsf.org/

For further information on the VIENNAAddIn project please visit 
http://vienna-add-in.googlecode.com
*******************************************************************************/
using System;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Xml;
using System.Xml.Schema;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using EA;
using VIENNAAddIn.Utils;
using VIENNAAddIn.Exceptions;
using VIENNAAddIn.common;
using VIENNAAddIn.constants;

namespace VIENNAAddIn.CCTS
{
    public partial class BIEGenerator : Form, GeneratorCallBackInterface
    {


        #region Variable
        private Repository repository;
        internal String scope;
        private Boolean annotate;
        private bool withGUI;
        private GeneratorCallBackInterface caller;
        private bool blnNillable = false;
        private bool blnAlias = false;
        private bool blnIncludeLinkedSchema = false;
        private bool DEBUG;

        //This ArrayList holds a List of all auxilliary schmeas
        //that had to be created for this schema to be valid
        //internal System.Collections.ArrayList alreadyCreatedSchemas = new ArrayList();
        internal System.Collections.ArrayList alreadyCreatedSchemas = new ArrayList();
        
        //This arraylist hold a list of auxilliary schema that generated by BusinessLibraryGenerator
        private ArrayList alreadyCreatedSchemasBLGen;// = new ArrayList();

        //if generate from anyLevel, its value will be true, otherwise if generated from specific package it will be false;
        private bool isAnyLevelGeneration = false;

        //The path where the schema(s) should be saved
        private String path = "";
        private String targetNameSpacePrefix = "bie";

        //These variables are used to make a distinction between namespaces of the same type
        static int countQDTImports = 0;
        static int countUDTImports = 0;
        static int countENUMImports = 0;
        static int countBIEImports = 0;

        //private CommonRoutineCCBIE test = null;
        //private enum typeLibraryEnum { CCLibrary, BIELibrary };
        //private enum typeElementEnum { ELEMENT, ATTRIBUTE, CONNECTOR };
        #endregion


        #region Constructor

        /// <sUMM2ary>
        /// Construct a new BIEGenerator
        /// </sUMM2ary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        public BIEGenerator(EA.Repository repository, String scope, bool annotate)
        {
            //Set the debug mode
            DEBUG = Utility.DEBUG;

            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            //With GUI
            this.withGUI = true;
            InitializeComponent();
            this.setActivePackageLabel();
            this.isAnyLevelGeneration = false;

            //this.test = new CommonRoutineCCBIE(repository, scope, annotate, this, typeLibraryEnum.BIELibrary.ToString());
            //test.isAnyLevelGeneration = false;
        }

        /// <summary>
        /// This constructor is made special for any-level schema generation
        /// </summary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        /// <param name="alreadyCreatedSchemaBLGen"></param>
        public BIEGenerator(EA.Repository repository, String scope, bool annotate, bool blnIncludeLinkedSchema, 
            bool blnAlias, bool blnNillable, string path, ArrayList alreadyCreatedSchemaBLGen)
        {
            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
            this.blnAlias = blnAlias;
            this.blnNillable = blnNillable;

            //With GUI
            this.withGUI = false;
            //InitializeComponent();
            //this.setActivePackageLabel();

            //this.test = new CommonRoutineCCBIE(repository, scope, annotate, this.blnIncludeLinkedSchema, this.blnAlias,
            //    this.blnNillable, path, alreadyCreatedSchemaBLGen, caller, typeLibraryEnum.BIELibrary.ToString(), true);

            //test.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
            //test.isAnyLevelGeneration = true;

            this.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
            this.isAnyLevelGeneration = true;
            this.path = path;
        }

        ////sementara, nyoba caller
        //public BIEGenerator(EA.Repository repository, String scope, bool annotate, string path, ArrayList alreadyCreatedSchemaBLGen, GeneratorCallBackInterface caller)
        //{
        //    this.repository = repository;
        //    this.scope = scope;
        //    this.annotate = annotate;
        //    this.caller = caller;//nyoba dulu 25sept08
        //    //With GUI
        //    this.withGUI = false;
        //    //InitializeComponent();
        //    //this.setActivePackageLabel();

        //    this.test = new CommonRoutineCCBIE(repository, scope, annotate, path, alreadyCreatedSchemaBLGen,
        //        caller, typeLibraryEnum.BIELibrary.ToString(), true);

        //    test.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
        //    test.isAnyLevelGeneration = true;

        //    //this.alreadyCreatedSchemasBLGen = alreadyCreatedSchemaBLGen;
        //    //this.isAnyLevelGeneration = true;
        //    //this.path = path;
        //}

        /// <sUMM2ary>
        /// Construct a BIEGenerator with no GUI
        /// </sUMM2ary>
        /// <param name="repository"></param>
        /// <param name="scope"></param>
        /// <param name="annotate"></param>
        public BIEGenerator(EA.Repository repository, String scope, bool annotate, bool blnIncludeLinkedSchema,
            bool blnAlias, bool blnNillable, String path, GeneratorCallBackInterface caller)
        {
            //Set the debug mode
            //DEBUG = Utility.DEBUG;

            this.caller = caller;
            this.repository = repository;
            this.scope = scope;
            this.annotate = annotate;
            this.blnIncludeLinkedSchema = blnIncludeLinkedSchema;
            this.blnAlias = blnAlias;
            this.blnNillable = blnNillable;
            this.withGUI = false;
            //Set the path from the caller because the CDT Generator now operates in not visible
            //mode and hence no path is determined in this class

            //this.test = new CommonRoutineCCBIE(repository, scope, annotate, this, typeLibraryEnum.BIELibrary.ToString());
            //test.path = path;
            //test.isAnyLevelGeneration = false;

            this.path = path;
            this.isAnyLevelGeneration = false;
        }


         //<sUMM2ary>
         //Creates a minimal BIEGenerator
         //The constructor is used to access the getABIEAnnotation methods
         //</sUMM2ary>
         //<param name="repository"></param>
         //<param name="scope"></param>
        public BIEGenerator(EA.Repository repository, String scope)
        {
            this.repository = repository;
            this.scope = scope;
            this.isAnyLevelGeneration = false;
        }
        #endregion


        #region implement interface

        /// <sUMM2ary>
        /// Append an error message to the status box
        /// </sUMM2ary>
        /// <param name="msg"></param>
        private void appendErrorMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("error", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                {
                    this.statusTextBox.Text += "ERROR: (Package: " + packageName + ") " + msg + "\n\n";
                }
            }
        }
        /// <sUMM2ary>
        /// Show a info message in the status box
        /// </sUMM2ary>
        /// <param name="msg"></param>
        private void appendInfoMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("info", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                {
                    this.statusTextBox.Text += "INFO: (Package: " + packageName + ") " + msg + "\n\n";
                }
            }
        }
        /// <sUMM2ary>
        /// Show a warn message in the status box
        /// </sUMM2ary>
        /// <param name="msg"></param>
        private void appendWarnMessage(String msg, String packageName)
        {
            if (caller != null)
            {
                caller.appendMessage("warn", msg, this.getPackageName());
            }
            else
            {
                if (this.withGUI)
                    this.statusTextBox.Text += "WARN: (Package: " + packageName + ") " + msg + "\n\n";
            }
        }


        /// <sUMM2ary>
        /// Is called from extern to append a message to this GUI
        /// </sUMM2ary>
        /// <param name="type"></param>
        /// <param name="message"></param>
        public void appendMessage(String type, String message, String packageName)
        {
            if (type == "info")
                this.appendInfoMessage(message, packageName);
            else if (type == "warn")
                this.appendWarnMessage(message, packageName);
            else if (type == "error")
                this.appendErrorMessage(message, packageName);

        }

        #endregion

        #region Special for this BIE generator
        /// <sUMM2ary>
        /// Setze den Generator zurück
        /// </sUMM2ary>
        /// <param name="scope"></param>
        public void resetGenerator(String scope)
        {
            this.scope = scope;
            //test.alreadyCreatedSchemas = new ArrayList();
            this.alreadyCreatedSchemas = new ArrayList();
            this.progressBar1.Value = this.progressBar1.Minimum;
            this.statusTextBox.Text = "";
            this.setActivePackageLabel();
        }

        /// <sUMM2ary>
        /// Cancel Button
        /// </sUMM2ary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void button2_Click(object sender, EventArgs e)
        {
            this.Close();
        }


        /// <sUMM2ary>
        /// Setze den Text der ausgewählten BIELibrary
        /// </sUMM2ary>
        private void setActivePackageLabel()
        {
            EA.Package p = this.repository.GetPackageByID(Int32.Parse(this.scope));
            this.selectedBIELibrary.Text = p.Element.Name + "<<" + p.Element.Stereotype.ToString() + ">>";
        }

        private void getCheckedOption()
        {
            if (this.annotateElementBox.Checked)
            {
                this.annotate = true;
                //test.annotate = true;
            }
            else
            {
                this.annotate = false;
                //test.annotate = false;
            }

            if (this.chkIncludeLinkedSchema.Checked)
            {
                this.blnIncludeLinkedSchema = true;
                //test.blnIncludeLinkedSchema = true;
            }
            else
            {
                this.blnIncludeLinkedSchema = false;
                //test.blnIncludeLinkedSchema = false;
            }

            if (this.chkUseAlias.Checked)
            {
                this.blnAlias = true;
                //test.blnAlias = true;
            }
            else
            {
                this.blnAlias = false;
                //test.blnAlias = false;
            }

            if (this.chkNillable.Checked)
            {
                this.blnNillable = true;
                //test.blnNillable = true;
            }
            else
            {
                this.blnNillable = false;
                //test.blnNillable = false;
            }
        }

        /// <sUMM2ary>
        /// Generate the Schema
        /// </sUMM2ary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnGenerateSchema_Click(object sender, EventArgs e)
        {

            resetGenerator(this.scope);

            getCheckedOption();

            //if (this.annotateElementBox.Checked)
            //{
            //    this.annotate = true;
            //    test.annotate = true;
            //}
            //else
            //{
            //    this.annotate = false;
            //    test.annotate = false;
            //}

            //if (this.chkIncludeLinkedSchema.Checked)
            //    CC_Utils.blnLinkedSchema = true;
            //else
            //    CC_Utils.blnLinkedSchema = false;


            ////using alias for package's name is prefered.
            //if (chkUseAlias.Checked)
            //    CC_Utils.blnAlias = true;
            //else
            //    CC_Utils.blnAlias = false;

            if (DEBUG)
            {
                path = "C:\\Dokumente und Einstellungen\\pliegl\\Desktop\\xsd-schema";
            }
            else
            {
                //First we need to know the path where to save the schema(s)            
                DialogResult dr = this.folderBrowserDialog1.ShowDialog(this);
                if (dr.Equals(DialogResult.Cancel))
                {
                    folderBrowserDialog1.Dispose();
                    return;
                }

                this.path = this.folderBrowserDialog1.SelectedPath;
            }

            if (this.path != null && !this.path.Equals(""))
            {

                this.path = this.path + "\\";
                //test.path = this.path + "\\";

                //Get the active Package
                EA.Package p = this.repository.GetPackageByID(Int32.Parse(this.scope));

                this.performProgressStep();

                String error = "";
                System.Collections.ICollection result = null;

                this.appendInfoMessage("Starting BIE schema creation. Please wait.", this.getPackageName());

                try
                {
                    result = generateSchema(p);
                }
                catch (Exception exc)
                {
                    error = exc.Message;
                }

                //Kein Fehler aufgetreten - schreibe das Ergebnis
                if (error == "")
                {
                    string baseURL = XMLTools.getBaseURL(repository, this.scope);
                    foreach (XmlSchema schema in result)
                    {
                        String schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(Int32.Parse(this.scope)), repository, this.blnAlias); 
                        String filename = path + schemaPath + XMLTools.getSchemaName(this.repository.GetPackageByID(Int32.Parse(this.scope)));
                        //Create the path
                        System.IO.Directory.CreateDirectory(path + schemaPath);
                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                        schema.Write(outputStream);
                        outputStream.Close();

                        if (baseURL != "")
                        {
                            EA.Package pkg = this.repository.GetPackageByID(Int32.Parse(this.scope));
                            string schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(Int32.Parse(this.scope)));
                            string webSchemaPath = baseURL + "/" + schemaPath.Replace("\\", "/") + schemaName;

                            //add the address to property of package
                            if (!IsSchemaExist(webSchemaPath, pkg))
                            {
                                EA.File myfile = (EA.File)pkg.Element.Files.AddNew(webSchemaPath, "Web Address");

                                myfile.Update();
                                pkg.Element.Files.Refresh();
                            }
                        }
                    }
                    this.appendInfoMessage("The schema was created successfully.", this.getPackageName());
                }
                else
                {
                    this.appendErrorMessage(error, this.getPackageName());
                }

                this.progressBar1.Value = this.progressBar1.Maximum;
            }
            else
            {
                this.appendErrorMessage("Plese select a location for the generated schemas first.", this.getPackageName());
            }
        }

        /// <sUMM2ary>
        /// Search for particular webSchemaPath
        /// </sUMM2ary>
        /// <param name="webSchemaPath">Web address for schema</param>
        /// <param name="pkg">Package</param>
        /// <returns></returns>
        private bool IsSchemaExist(string webSchemaPath, EA.Package pkg)
        {
            foreach (EA.File file in pkg.Element.Files)
            {
                if (file.Name == webSchemaPath)
                    return true;
            }
            return false;
        }


        /// <sUMM2ary>
        /// Performs a step with the progress bar
        /// </sUMM2ary>
        public void performProgressStep()
        {
            if (this.withGUI)
            {
                this.progressBar1.PerformStep();
            }
            else
            {
                //Is there a caller for this class?
                if (caller != null)
                    caller.performProgressStep();
            }
        }


        public static void ValidationCallbackOne(object sender, ValidationEventArgs args)
        {
            throw new XmlSchemaException(args.Message + args.Exception.StackTrace);
        }

        ///<sUMM2ary>
        /// Returns the name of the current package
        /// </sUMM2ary>
        /// <returns></returns>
        private String getPackageName()
        {
            return this.repository.GetPackageByID(Int32.Parse(this.scope)).Name.ToString();
        }

        private void chkNillable_CheckedChanged(object sender, EventArgs e)
        {
            if (chkNillable.Checked == true)
            {
                DialogResult result = MessageBox.Show("CAUTION: The resultant schemas may not be compliant with UN/CEFACT Naming and Design Rules." +
                "\nPlease confirm with your business domain owner before enabling." + "\nAre you sure want to continue?",
                "Warning", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);

                if (result == DialogResult.Yes)
                {
                    chkNillable.Checked = true;
                    //test.blnNillable = true;
                }
                else
                {
                    chkNillable.Checked = false;
                    //test.blnNillable = false;
                }
            }
            else
                chkNillable.Checked = false;
        }


        /// <sUMM2ary>
        /// Generate a schema out of the given ABIEs
        /// </sUMM2ary>
        /// <param name="p"></param>
        public System.Collections.ICollection generateSchema(EA.Package p)
        {
            ArrayList rootCollection = new ArrayList();

            //Validate the BIELibrary first
            String validationError = new BCSSValidator(this.repository, this.scope).validateBIELibrary();
            if (validationError != "")
            {
                //this.caller.appendMessage("error", validationError, this.getPackageName());
                //throw (new XMLException("Nested error. Please see error message above."));
                throw (new Exception(validationError));
            }

            XmlSchema schema = new XmlSchema();

            schema.ElementFormDefault = XmlSchemaForm.Qualified;
            schema.AttributeFormDefault = XmlSchemaForm.Unqualified;
            schema.Version = XMLTools.getSchemaVersionFromPackage(p);

            //Add the namespaces necessary for the BIE schema
            //test.addNameSpaces(schema);
            addNameSpaces(schema);

            int elementCount = 0;

            //Iterate through the ABIEs
            //foreach (EA.Element element in p.Elements) --> change "foreach" to "for" (special for looping through EA collection to avoid crash on release mode
            for (short idx=0; idx<p.Elements.Count; idx++)
            {
                EA.Element element = (EA.Element)p.Elements.GetAt(idx);
                elementCount++;
                if (element.Stereotype.Equals(CCTS_Types.ABIE.ToString()))
                {
                    XmlSchemaComplexType el = getSchemaElement(element, schema); //test.getSchemaElement(element, schema);
                    if (el != null)
                        schema.Items.Add(el);
                }

                if (XMLTools.getElementTVValue("isRoot", element).Equals("true", StringComparison.OrdinalIgnoreCase))
                    rootCollection.Add(element);

                //After every 20th iteration we  perform one progress step
                if (elementCount % 20 == 0)
                    this.performProgressStep();
            }

            addRootElement(schema, rootCollection);


            //Validate the Schema
            XmlSchemaSet xsdSet = new XmlSchemaSet();
            xsdSet.XmlResolver = null;
            xsdSet.ValidationEventHandler += new ValidationEventHandler(ValidationCallbackOne);
            try
            {
                //Add the actual schema
                xsdSet.Add(schema);
                //xsdSet.Compile();
            }
            catch (XmlSchemaException xse)
            {
                //this.appendErrorMessage(xse.Message + "\n" + xse.StackTrace.ToString(), "");                
                throw xse;
            }
            return xsdSet.Schemas();
        }

        /// <summary>
        /// Adds the root element to the schema
        /// </summary>
        /// <param name="schema"></param>
        /// <param name="rootElementID"></param>
        private void addRootElement(XmlSchema schema, ArrayList rootCollection)
        {
            foreach (EA.Element element in rootCollection)
            {
                EA.Element e = this.repository.GetElementByID(element.ElementID);

                XmlSchemaElement rootElement = new XmlSchemaElement();
                rootElement.Name = XMLTools.getXMLName(e.Name);
                rootElement.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(e.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));

                schema.Items.Add(rootElement);
            }
        }
        #endregion

        #region remove to CommonRoutineCCBIE




        //        /// <sUMM2ary>
//        /// Creates a Schema Element for the passed EA.Element
//        /// </sUMM2ary>
//        /// <param name="e"></param>
//        /// <returns></returns>
//        private XmlSchemaComplexType getSchemaElement(EA.Element e, XmlSchema schema)
//        {

//            //Create an new ComplexType for the passed ABIE
//            XmlSchemaComplexType complexType = new XmlSchemaComplexType();
//            complexType.Name = XMLTools.getXMLName(e.Name) + "Type";
//            XmlSchemaSequence sequence = new XmlSchemaSequence();

//            if (!XMLTools.isElementAlreadyIncludedInSchema(schema, complexType.Name))
//            {
//                //Get the annotation
//                if (annotate)
//                    complexType.Annotation = getABIEAnnotation(e);

//                #region get attribute

//                ArrayList tempPostion = new ArrayList();
//                ArrayList tempNoPostion = new ArrayList();

//                foreach (EA.Attribute attr in e.Attributes)
//                {
//                    SearchAttributeForPositionTaggedValue(attr, tempPostion, tempNoPostion);
//                }

//                #endregion

//                #region get aggregation

//                //Now check, whether there are any ASBIEs
//                foreach (EA.Connector con in e.Connectors)
//                {
//                    if (con.Type == EA_Element.Aggregation.ToString() && con.Stereotype.ToString() == CCTS_Types.ASBIE.ToString()
//                        && con.SupplierID == e.ElementID)
//                    {
//                        //Elements within the BIE library may have connectors which lead to DOCLibraries
//                        //(because BIEs are used within DOCLibraries)
//                        //Ignore such connectors                    
//                        EA.ConnectorEnd clientEnd = con.ClientEnd;
//                        EA.Element client = this.repository.GetElementByID(con.ClientID);
//                        EA.Element supplier = this.repository.GetElementByID(con.SupplierID);

//                        //Is the connection type an Aggregation or a Composition?
//                        //A composition == 2
//                        bool isComposition = false;
//                        if (con.SupplierEnd.Aggregation == 2)
//                        {
//                            isComposition = true;
//                        }
//                        String elementName = "";

//                        //If a role name is specified, we take the name of the
//                        //role and create a new element from it (if it does not already exist)
//                        //If a role name is specified, the name is
//                        //Supplier.Name + Role.Name + Client.Name
//                        if (clientEnd.Role != "")
//                        {
//                            elementName = XMLTools.getXMLName(clientEnd.Role + client.Name);
//                        }
//                        else
//                        {
//                            //If no role name is specified, the name is
//                            //Supplier.Name + Client.Name
//                            elementName = XMLTools.getXMLName(client.Name);
//                        }


//                        if (isInSamePackage(client))
//                        {
//                            #region in the same package
//                            //if (!isComposition) {
//                            //    if (!XMLTools.isElementAlreadyIncludedInSchema(schema, elementName)) {
//                            //        //We need to create a new element
//                            //        XmlSchemaElement xel = new XmlSchemaElement();
//                            //        xel.Name = elementName;
//                            //        xel.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
//                            //        schema.Items.Add(xel);
//                            //    }
//                            //}

//                            //Now add a reference to this element to the sequence
//                            XmlSchemaElement elemRef = new XmlSchemaElement();

//                            //Annotate?
//                            if (annotate)
//                                elemRef.Annotation = getASBIEAnnotation(con);

//                            ////Set the cardinality of the element
//                            this.setASBIECardinality(elemRef, clientEnd.Cardinality);

//                            //If the association is a composition we have to declare the ASBIE
//                            //locally

//                            //aggregation or composition is treated the same way - for quick fix
//                            //if (isComposition) {
//                            elemRef.Name = elementName;
//                            elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));
//                            //}
//                            //else {
//                            //    elemRef.RefName = new XmlQualifiedName(elementName, XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
//                            //}

//                            #region search for 'position' tagged value
//                            //aggregation or composition is treated the same way - for quick fix
//                            //if (isComposition)
//                            SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

//                            #endregion
//                            #endregion
//                        }
//                        //Not from this BIELibrary
//                        else
//                        {
//                            #region not from this BIELibrary
//                            //check if the package is already exist to avoid infinite loop
//                            //if (!(con.SupplierID == e.ElementID))
//                            //{
//                                //We only import other elements if they are located in a BIELibrary
//                                EA.Package p = this.repository.GetPackageByID(client.PackageID);
//                                if (p.Element.Stereotype.Equals(CCTS_Types.BIELibrary.ToString()))
//                                {

//                                    XmlQualifiedName qName = createAndImportAuxilliarySchema(client, schema);
//                                    XmlSchemaElement elemRef = new XmlSchemaElement();
//                                    //Annotate?
//                                    if (annotate)
//                                        elemRef.Annotation = getASBIEAnnotation(con);

//                                    ////Set the cardinality of the element
//                                    this.setASBIECardinality(elemRef, clientEnd.Cardinality);

//                                    //If the association is a composition we have to declare the ASBIE
//                                    //locally
//                                    //aggregation or composition is treated the same way - for quick fix
//                                    //if (isComposition) {
//                                    elemRef.Name = elementName;
//                                    elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(client.PackageID)));
//                                    //}
//                                    //else {
//                                    //    elemRef.RefName = qName;
//                                    //}

//                                    #region search for 'position' tagged value
//                                    //aggregation or composition is treated the same way - for quick fix
//                                    //if (isComposition)
//                                    SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

//                                    #endregion
                            
//                                }
//                            //}
//                            #endregion
//                        }
//                    }
//                }

//                #endregion

//                #region Sort the BBIE and ASBIE
//                //sort connector, then insert it into sequence
//                SortByPosition comparerPosition = new SortByPosition();
//                SortByName comparerName = new SortByName();

//                tempPostion.Sort(comparerPosition);
//                tempNoPostion.Sort(comparerName);

//                //sort the element with "position" tagged value
//                foreach (object obj in tempPostion)
//                {
//                    if (((ArrayList)obj)[2].ToString() == "Attribute")
//                    {
//                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
//                        if (attribute.Stereotype.Equals(CCTS_Types.BBIE.ToString()))
//                        {
//                            XmlSchemaElement attrElem = new XmlSchemaElement();
//                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
//                            //Set the type
//                            setBBIEType(attrElem, attribute, schema, e);
//                            //Set the cardinality
//                            setBBIECardinality(attrElem, attribute);
//                            //Get the annotation
//                            if (annotate)
//                                attrElem.Annotation = getBBIEAnnotation(attribute);
//                            //check for lower cardinality, if lower bound = 0, add nillable attribute
//                            if (getCaller().GetType() == typeof(DOCGenerator))
//                            {
//                                DOCGenerator theCaller = (DOCGenerator)getCaller();
//                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
//                                    attrElem.IsNillable = true;
//                            }
//                            else
//                            {
//                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
//                                    attrElem.IsNillable = true;
//                            }

//                            //Add the element to the sequence
//                            sequence.Items.Add(attrElem);
//                        }
//                    }
//                    else if (((ArrayList)obj)[2].ToString() == "Connector")
//                    {
//                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
//                        sequence.Items.Add(schemaElement);
//                    }

//                }

//                //sort the element alphabetically
//                foreach (object obj in tempNoPostion)
//                {
//                    if (((ArrayList)obj)[2].ToString() == "Attribute")
//                    {
//                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
//                        if (attribute.Stereotype.Equals(CCTS_Types.BBIE.ToString()))
//                        {
//                            XmlSchemaElement attrElem = new XmlSchemaElement();
//                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
//                            //Set the type
//                            setBBIEType(attrElem, attribute, schema, e);
//                            //Set the cardinality
//                            setBBIECardinality(attrElem, attribute);
//                            //Get the annotation
//                            if (annotate)
//                                attrElem.Annotation = getBBIEAnnotation(attribute);

//                            //check for lower cardinality, if lower bound = 0, add nillable attribute
//                            if (getCaller().GetType() == typeof(DOCGenerator))
//                            {
//                                DOCGenerator theCaller = (DOCGenerator)getCaller();
//                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
//                                    attrElem.IsNillable = true;
//                            }
//                            else
//                            {
//                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
//                                    attrElem.IsNillable = true;
//                            }

//                            //Add the element to the sequence
//                            sequence.Items.Add(attrElem);
//                        }
//                    }
//                    else if (((ArrayList)obj)[2].ToString() == "Connector")
//                    {
//                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
//                        sequence.Items.Add(schemaElement);
//                    }
//                }

//                //generate warning if there is a mix sort, alphabetically and sequence
//                if ((tempPostion.Count > 0) && (tempNoPostion.Count > 0))
//                    this.appendWarnMessage("There is a mix of sequence and alphabetic sorting of attributes (BBIEs) and aggregations (ASBIEs)", this.getPackageName());

//                #endregion
//            }

//            complexType.Particle = sequence;

//            return complexType;


//            //return null;
//        }


//        /// <sUMM2ary>
//        /// Search Connector with "position" tagged value
//        /// if exist, sort by "position", then the rest sort alphabethically
//        /// The Array tempPosition/tempNoPostion structure : 
//        /// [0] value of "position" tagged value
//        /// [1] the element with type XMLSchemaElement
//        /// [2] type (Attribute or Connector)-> used for sorting
//        /// </sUMM2ary>
//        /// <returns></returns>
//        private void SearchConnectorForPositionTaggedValue(EA.Collection col, ArrayList tempPosition, ArrayList tempNoPosition, XmlSchemaElement elemRef)
//        {
//            bool isError = false;
//            bool isPositionExist = false;


//            //search for attribute's tagged value 'position'
//            foreach (EA.ConnectorTag tagval in col)
//            {
//                //if "position" tagged value exist and has value
//                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != ""))
//                {
//                    ArrayList temp = new ArrayList();
//                    isPositionExist = true;

//                    try
//                    {
//                        //convert str to int,test if the value of tagged value is an integer
//                        Convert.ToInt16(tagval.Value);
//                    }
//                    catch (Exception ex)
//                    {
//                        isError = true;
//                    }
//                    if (!isError)
//                    {
//                        temp.Add(tagval.Value);
//                        temp.Add(elemRef);
//                        temp.Add("Connector");

//                        tempPosition.Add(temp);
//                        break;
//                    }
//                }
//            }

//            if ((!isPositionExist) || ((isPositionExist) && (isError)))
//            {
//                ArrayList temp = new ArrayList();
//                temp.Add(elemRef.Name);
//                temp.Add(elemRef);
//                temp.Add("Connector");

//                tempNoPosition.Add(temp);
//            }
//        }


//        /// <sUMM2ary>
//        /// Search Attribute with "position" tagged value
//        /// if exist, sort by "position", then the rest sort alphabethically
//        /// The Array tempPosition/tempNoPostion structure : 
//        /// [0] value of "position" tagged value
//        /// [1] the attribute with type EA.Attribute
//        /// [2] type (Attribute or Connector)-> used for sorting
//        /// </sUMM2ary>
//        /// <returns></returns>
//        //private void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempAttr, ArrayList tempAttrWithPosition)
//        private void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempPosition, ArrayList tempNoPosition)
//        {
//            bool isError = false;
//            bool isPositionExist = false;

//            foreach (EA.AttributeTag tagval in attr.TaggedValues)
//            {
//                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != null))
//                {
//                    ArrayList temp = new ArrayList();
//                    isPositionExist = true;

//                    try
//                    {
//                        //convert str to int,test if the value of tagged value is an integer
//                        Convert.ToInt16(tagval.Value);
//                    }
//                    catch (Exception ex)
//                    {
//                        isError = true;
//                        break;
//                    }
//                    if (!isError)
//                    {
//                        temp.Add(tagval.Value);
//                        temp.Add(attr);
//                        temp.Add("Attribute");

//                        tempPosition.Add(temp);
//                        break;
//                    }
//                }
//            }

//            if ((!isPositionExist) || ((isPositionExist) && (isError)))
//            {
//                ArrayList temp = new ArrayList();
//                temp.Add(attr.Name);
//                temp.Add(attr);
//                temp.Add("Attribute");

//                tempNoPosition.Add(temp);
//            }
//        }


//        private XmlQualifiedName createAndImportAuxilliarySchema(EA.Element e, XmlSchema schema)
//        {
//            //Get the package of origin of the element
//            EA.Package p = this.repository.GetPackageByID(e.PackageID);
//            String pName = p.Name;
//            String s = "";
            
//            //if the generation is from any level generation
//            if (isAnyLevelGeneration)
//            {
//                String sBLGen = "";
//                //is the schema already included in global array?
//                if ((s = isSchemaAlreadyIncluded(p.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(p.Name)) != "")
//                {
//                    #region for any level package generation, to check if there was previously generated schema
//                    ////We need to add an import statement for the newly generated schema
//                    ////to the original schema
//                    ////if (different package than previously generated) and !(already included)

//                    AuxilliarySchema aux = new AuxilliarySchema();
//                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
//                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
//                    aux.PackageOfOrigin = p.Name.ToString();

//                    //String schemaPath = "";
//                    String schemaName = "";
//                    //schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository);
//                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
//                    //String filename = path + schemaPath + schemaName;


//                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, CC_Utils.blnAlias);

//                    addImport(schema, importPath, aux.Namespace);

//                    //We need to add the namespace of this schema to the main schema
//                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

//                    //Set the namespace to the variable which is then used down below
//                    s = aux.Namespace;

//                    //add the schema to local alreadyCreatedSchema
//                    this.alreadyCreatedSchemas.Add(aux);
//                    #endregion
//                }
//            }

//            //Is this schema already included?
//            if ((s = isSchemaAlreadyIncluded(p.Name)) == "")
//            {
//                if (!CC_Utils.blnLinkedSchema)
//                {
//                    #region Include linked schema unchecked - for particular generation only
//                    AuxilliarySchema aux = new AuxilliarySchema();
//                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
//                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
//                    aux.PackageOfOrigin = p.Name.ToString();
//                    this.alreadyCreatedSchemas.Add(aux);

//                    String schemaName = "";
//                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));

//                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, CC_Utils.blnAlias);

//                    addImport(schema, importPath, aux.Namespace);

//                    //We need to add the namespace of this schema to the main schema
//                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

//                    //Set the namespace to the variable which is then used down below
//                    s = aux.Namespace;
//                    #endregion
//                }
//                else
//                {
//                    #region Include linked schema checked
//                    //System.Collections.ICollection result = new BIEGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(p);
                    
//                    System.Collections.ICollection result;
//                    if (this.isAnyLevelGeneration)
//                    {
//                        #region schema generation from any level
//                        if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.DOCLibrary.ToString())
//                        {
//                            result = new DOCGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.BIELibrary.ToString())
//                        {
//                            result = new BIEGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.CDTLibrary.ToString())
//                        {
//                            result = new CDTGenerator(this.repository, p.PackageID.ToString(), annotate, this.path).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.ENUMLibrary.ToString())
//                        {
//                            result = new ENUMGenerator(this.repository, p.PackageID.ToString(), annotate, this.path).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.QDTLibrary.ToString())
//                        {
//                            result = new QDTGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
//                        }
//                        else
//                            throw new Exception("Linked schema generation from package <<" + p.Element.Stereotype + ">>" + p.Name + "currently is not supported");
//                        #endregion
//                    }
//                    else
//                    {
//                        #region schema generation from particular package
//                        if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.DOCLibrary.ToString())
//                        {
//                            result = new DOCGenerator(this.repository, p.PackageID.ToString(), annotate, this.path).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.BIELibrary.ToString())
//                        {
//                            result = new BIEGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.CDTLibrary.ToString())
//                        {
//                            result = new CDTGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.ENUMLibrary.ToString())
//                        {
//                            result = new ENUMGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(p);
//                        }
//                        else if (this.repository.GetPackageByID(p.PackageID).Element.Stereotype.ToString() == CCTS_PackageType.QDTLibrary.ToString())
//                        {
//                            result = new QDTGenerator(this.repository, p.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(p);
//                        }
//                        else
//                            throw new Exception("Linked schema generation from package <<" + p.Element.Stereotype + ">>" + p.Name + "currently is not supported");
//                        #endregion
//                    }

//                    //Create an Auxilliary schema and store it in the collection - later we have to
//                    //add it to the main schema collection
//                    AuxilliarySchema aux = new AuxilliarySchema();
//                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
//                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
//                    aux.PackageOfOrigin = p.Name.ToString();
//                    aux.Schemas = result;

//                    //Add the name of the already-generated schema to local array
//                    this.alreadyCreatedSchemas.Add(aux);

//                    //Add the name of the already-generated schema to global array for any-level generation
//                    if (isAnyLevelGeneration)
//                        this.alreadyCreatedSchemasBLGen.Add(aux);

                    
//                    String schemaPath = "";
//                    String schemaName = "";
//                    schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository, CC_Utils.blnAlias);
//                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
//                    String filename = path + schemaPath + schemaName;

//                    //Write the schema(s)
//                    foreach (XmlSchema schema1 in result)
//                    {
//                        //Create the path
//                        System.IO.Directory.CreateDirectory(path + schemaPath);
//                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
//                        schema1.Write(outputStream);
//                        outputStream.Close();
//                    }

//                    //We need to add an import statement for the newly generated schema
//                    //to the original schema
//                    String importPath = XMLTools.getImportPathForSchema(p, repository, schemaName, scope, CC_Utils.blnAlias);

//                    addImport(schema, importPath, aux.Namespace);

//                    //We need to add the namespace of this schema to the main schema
//                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

//                    //Set the namespace to the variable which is then used down below
//                    s = aux.Namespace;
//                    #endregion
//                }
//            }

//            return new XmlQualifiedName(e.Name + "Type", s);

//        }







//        /// <sUMM2ary>
//        /// Return the Annotation for a given ASBIE element
//        /// </sUMM2ary>
//        /// <param name="name"></param>
//        /// <returns></returns>
//        public XmlSchemaAnnotation getASBIEAnnotation(EA.Connector con)
//        {
//            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
//            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
//            doc.Language = "en";

//            XmlDocument xml = new XmlDocument();

//            //These arrays hold the names and the values of the annotation
//            String[] nodes = { "*UniqueID", 
//                "*Acronym", 
//                "*DictionaryEntryName", 
//                "*Version", 
//                "*Definition", 
//                "*Cardinality", 
//                "*ObjectClassTerm", 
//                "*ObjectClassQualifierTerm", 
//                "*PropertyTerm", 
//                "*PropertyQualifierTerm", 
//                "*AssociatedObjectClassTerm", 
//                "*AssociatedObjectClassQualifierTerm", 
//                "*AssociationType", 
//                "*BusinessProcessContextValue", 
//                "*GeopoliticalOrRegionContextValue", 
//                "*OfficialConstraintContextValue", 
//                "*ProductContextValue", 
//                "*IndustryContextValue", 
//                "*BusinessProcessRoleContextValue", 
//                "*SupportingRoleContextValue", 
//                "*SystemCapabilitiesContextValue", 
//                "*UsageRule", 
//                "*BusinessTerm",     
//                "*Example",
//                "*RepresentationLayout" //,
//                //"*Notes"
//            };

//            String[] values = { XMLTools.getConnectorTVValue(CCTS_TV.UniqueID,con), 
//                "ASBIE", 
//                XMLTools.getConnectorTVValue(CCTS_TV.DictionaryEntryName,con), 
//                XMLTools.getConnectorTVValue(CCTS_TV.Version,con),  
//                XMLTools.getConnectorTVValue(CCTS_TV.Definition,con), 
//                getASBIECardinality(con.ClientEnd), 
//                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassTerm,con),  
//                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassQualifierTerm,con),  
//                XMLTools.getConnectorTVValue(CCTS_TV.PropertyTerm,con),  
//                XMLTools.getConnectorTVValue(CCTS_TV.PropertyQualifierTerm,con),  
//                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassTerm,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassQualifierTerm,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.AssociationType,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.GeopoliticalOrRegionContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.OfficialConstraintContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.ProductContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.IndustryContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.SupportingRoleContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.SystemCapabilitiesContextValue,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.UsageRule,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.BusinessTerm,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.Example,con),
//                XMLTools.getConnectorTVValue(CCTS_TV.RepresentationLayout,con)//,
//                //con.Notes
//            };

//            XmlNode[] annNodes = new XmlNode[nodes.Length];
//            for (int i = 0; i < nodes.Length; i++)
//            {
//                //If a node is optional (a node is optional if its name starts with a *)
//                //we only include it, if a value is specified
//                bool include = true;
//                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
//                {
//                    include = false;
//                }
//                if (include)
//                {
//                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
//                    if (values[i] != "")
//                        node.InnerText = values[i];
//                    annNodes[i] = node;
//                }
//            }

//            doc.Markup = annNodes;
//            ann.Items.Add(doc);

//            return ann;
//        }


//        /// <sUMM2ary>
//        /// Return the ASBIE Cardinality
//        /// </sUMM2ary>
//        /// <param name="clientEnd"></param>
//        /// <returns></returns>
//        private String getASBIECardinality(EA.ConnectorEnd clientEnd)
//        {

//            if (clientEnd.Cardinality == "")
//                return "1";
//            else
//                return clientEnd.Cardinality;
//        }




//        /// <sUMM2ary>
//        /// Sets the cardinality of the element according to the information in the 
//        /// AggregateBusinessInformationEntity
//        /// This proves to be a little bit more tricky than with the BBIE because we
//        /// receive only one String containing both, the upper and the lower bound
//        /// </sUMM2ary>
//        /// <param name="e1"></param>
//        /// <param name="abie"></param>
//        public void setASBIECardinality(XmlSchemaElement e1, String c)
//        {

//            String lower = "";
//            String upper = "";
//            try
//            {
//                //Try to split up the String
//                String cardinality = c;
//                lower = cardinality.Substring(0, 1);
//                upper = cardinality.Substring(3);
//            }
//            catch { }

//            try
//            {
//                //Try to set the lower
//                int i = Int32.Parse(lower);
//                e1.MinOccurs = i;
//            }
//            catch { }

//            try
//            {
//                //Try to set the upper
//                if (upper == "*")
//                    e1.MaxOccursString = "unbounded";
//                else
//                {
//                    int i = Int32.Parse(upper);
//                    if (i != 1)
//                        e1.MaxOccurs = i;
//                }
//            }
//            catch { }

//        }




//        /// <sUMM2ary>
//        /// Return the Annotation for a given ABIE element
//        /// </sUMM2ary>
//        /// <param name="name"></param>
//        /// <returns></returns>
//        public XmlSchemaAnnotation getABIEAnnotation(EA.Element abie)
//        {
//            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
//            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
//            doc.Language = "en";

//            XmlDocument xml = new XmlDocument();
//            //These arrays hold the names and the values of the annotation
//            String[] nodes = { "*UniqueID", 
//                "*Acronym", 
//                "*DictionaryEntryName", 
//                "*Version", 
//                "*Definition", 
//                "*ObjectClassTerm", 
//                "*ObjectClassQualifierTerm", 
//                "*BusinessProcessContextValue", 
//                "*GeopoliticalOrRegionContextValue", 
//                "*OfficialConstraintContextValue", 
//                "*ProductContextValue", 
//                "*IndustryContextValue", 
//                "*BusinessProcessRoleContextValue", 
//                "*SupportingRoleContextValue", 
//                "*SystemCapabilitiesContextValue", 
//                "*UsageRule", 
//                "*BusinessTerm", 
//                "*Example",
//                "*RepresentationLayout"//,
//                //"*Notes"
//            };

//            //Get ObjectClassTerm & ObjectClassQualifierTerm
//            string[] objClassTerm = GetObjectClassTerm(abie);

//            String[] values = { XMLTools.getElementTVValue(CCTS_TV.UniqueID, abie), 
//                "ABIE", 
//                XMLTools.getElementTVValue(CCTS_TV.DictionaryEntryName, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.Version, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.Definition, abie),
//                objClassTerm[1] != null ? objClassTerm[1] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassTerm, abie), 
//                objClassTerm[0] != null ? objClassTerm[0] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassQualifierTerm, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessContextValue, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, abie),                  
//                XMLTools.getElementTVValue(CCTS_TV.OfficialConstraintContextValue, abie),                
//                XMLTools.getElementTVValue(CCTS_TV.ProductContextValue, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.IndustryContextValue, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessRoleContextValue, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.SupportingRoleContextValue, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.SystemCapabilitiesContextValue, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.UsageRule, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.BusinessTerm, abie), 
//                XMLTools.getElementTVValue(CCTS_TV.Example, abie),
//                XMLTools.getElementTVValue(CCTS_TV.RepresentationLayout, abie)//,
//                //abie.Notes
//            };

//            XmlNode[] annNodes = new XmlNode[nodes.Length];
//            for (int i = 0; i < nodes.Length; i++)
//            {
//                //If a node is optional (a node is optional if its name starts with a *)
//                //we only include it, if a value is specified
//                bool include = true;
//                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
//                {
//                    include = false;
//                }
//                if (include)
//                {
//                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
//                    if (values[i] != "")
//                        node.InnerText = values[i];
//                    annNodes[i] = node;
//                }
//            }

//            doc.Markup = annNodes;
//            ann.Items.Add(doc);

//            return ann;
//        }

//        private string[] GetObjectClassTerm(Element abie)
//        {
//            string[] objClassTerm = new string[2];
//            foreach (EA.TaggedValue tg in abie.TaggedValues)
//            {
//                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
//                {
//                    string dict = tg.Value;
//                    string[] partsOfDEN = null;

//                    //split the Dictionary Entry Name into three part
//                    for (int i = 1; i < 4; i++)
//                    {
//                        partsOfDEN = dict.Split(".".ToCharArray(), i);
//                    }

//                    string[] splitFirstPart = null;
//                    //split the first part of DEN
//                    for (int i = 1; i < 3; i++)
//                    {
//                        splitFirstPart = partsOfDEN[0].Split("_".ToCharArray(), i);
//                    }
//                    if (splitFirstPart.GetUpperBound(0) == 1)  // "object class term qualifier" is exist
//                    {
//                        objClassTerm[0] = splitFirstPart[0]; //object class term qualifier
//                        objClassTerm[1] = splitFirstPart[1]; //Object Class Term
//                    }
//                    else
//                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term

//                    break;
//                }
//            }
//            return objClassTerm;
//        }






//        /// <sUMM2ary>
//        /// Return the Annotation for a given BBIE element
//        /// </sUMM2ary>
//        /// <returns></returns>
//        public XmlSchemaAnnotation getBBIEAnnotation(EA.Attribute bbie)
//        {
//            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
//            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
//            doc.Language = "en";

//            XmlDocument xml = new XmlDocument();

//            String card = bbie.LowerBound + ".." + bbie.UpperBound;
//            //These arrays hold the names and the values of the annotation
//            String[] nodes = { "*UniqueID", 
//                "*Acronym", 
//                "*DictionaryEntryName", 
//                "*Version", 
//                "*Definition", 
//                "*Cardinality", 
//                "*ObjectClassTerm", 
//                "*ObjectClassQualifierTerm", 
//                "*PropertyTerm", 
//                "*PropertyQualifierTerm", 
//                "*PrimaryRepresentationTerm", 
//                "*BusinessProcessContextValue", 
//                "*GeopoliticalOrRegionContextValue", 
//                "*OfficialConstraintContextValue", 
//                "*ProductContextValue", 
//                "*IndustryContextValue", 
//                "*BusinessProcessRoleContextValue", 
//                "*SupportingRoleContextValue", 
//                "*SystemCapabilitiesContextValue", 
//                "*UsageRule", 
//                "*BusinessTerm", 
//                "*Example",
//                "*RepresentationLayout"//,
//                //"*Notes"
//            };

//            //Get ObjectClassTerm & ObjectClassQualifierTerm
//            string[] objClassTerm = GetObjectClassTermBBIE(bbie);

//            String[] values = { XMLTools.getAttributeTVValue(CCTS_TV.UniqueID, bbie), 
//                "BBIE", 
//                XMLTools.getAttributeTVValue(CCTS_TV.DictionaryEntryName, bbie), 
//                XMLTools.getAttributeTVValue(CCTS_TV.Version, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.Definition, bbie), 
//                card, 
//                objClassTerm != null ? (objClassTerm[1] != null ? objClassTerm[1] : "") : "" ,//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassTerm, bbie), 
//                objClassTerm != null ? (objClassTerm[0] != null ? objClassTerm[0] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassQualifierTerm, bbie), 
//                objClassTerm != null ? (objClassTerm[3] != null ? objClassTerm[3] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyTerm, bbie), 
//                objClassTerm != null ? (objClassTerm[2] != null ? objClassTerm[2] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyQualifierTerm, bbie),
//                objClassTerm != null ? (objClassTerm[4] != null ? objClassTerm[4] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PrimaryRepresentationTerm, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.OfficialConstraintContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.ProductContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.IndustryContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.SupportingRoleContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.SystemCapabilitiesContextValue, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.UsageRule, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.BusinessTerm, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.Example, bbie),
//                XMLTools.getAttributeTVValue(CCTS_TV.RepresentationLayout, bbie)//,
//                //bbie.Notes
                
//            };

//            XmlNode[] annNodes = new XmlNode[nodes.Length];
//            for (int i = 0; i < nodes.Length; i++)
//            {
//                //If a node is optional (a node is optional if its name starts with a *)
//                //we only include it, if a value is specified
//                bool include = true;
//                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
//                {
//                    include = false;
//                }
//                if (include)
//                {
//                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
//                    if (values[i] != "")
//                        node.InnerText = values[i];
//                    annNodes[i] = node;
//                }
//            }

//            doc.Markup = annNodes;
//            ann.Items.Add(doc);

//            return ann;
//        }

//        private string[] GetObjectClassTermBBIE(EA.Attribute bbie)
//        {
//            string[] objClassTerm = new string[6];
//            foreach (EA.AttributeTag tg in bbie.TaggedValues)
//            {
//                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
//                {
//                    string dict = tg.Value;
//                    string[] partsOfDEN = null;

//                    //split the Dictionary Entry Name into three part
//                    for (int i = 1; i < 4; i++)
//                    {
//                        partsOfDEN = dict.Split(".".ToCharArray(), i);
//                    }

//                    if (partsOfDEN.GetUpperBound(0) != 2)  //if the DEN doesn't have correct parts. The correct DEN must have 3 parts.
//                        return null;

//                    //split first part of DEN
//                    string[] splitFirstPart = null;
//                    splitFirstPart = SplitDEN(partsOfDEN[0]);

//                    if (splitFirstPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
//                    {
//                        string qualifier = "";
//                        for (int a = 0; a < splitFirstPart.GetUpperBound(0); a++)
//                        {
//                            if (a == (splitFirstPart.GetUpperBound(0) - 1))
//                                qualifier += splitFirstPart[a];
//                            else
//                                qualifier += splitFirstPart[a] + "_";
//                        }
//                        objClassTerm[0] = qualifier; //object class term qualifier
//                        objClassTerm[1] = splitFirstPart[splitFirstPart.GetUpperBound(0)]; //Object Class Term
//                    }
//                    else
//                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term


//                    //split second part of DEN
//                    string[] splitSecondPart = null;
//                    splitSecondPart = SplitDEN(partsOfDEN[1]);

//                    if (splitSecondPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
//                    {
//                        string qualifier = "";
//                        for (int a = 0; a < splitSecondPart.GetUpperBound(0); a++)
//                        {
//                            if (a == (splitSecondPart.GetUpperBound(0) - 1))
//                                qualifier += splitSecondPart[a];
//                            else
//                                qualifier += splitSecondPart[a] + "_";
//                        }
//                        objClassTerm[2] = qualifier; //property term qualifier
//                        objClassTerm[3] = splitSecondPart[splitSecondPart.GetUpperBound(0)]; //Property Term
//                    }
//                    else
//                        objClassTerm[2] = partsOfDEN[1]; //Object Class Term

//                    //split third part of DEN
//                    string[] splitThirdPart = null;
//                    splitThirdPart = SplitDEN(partsOfDEN[2]);

//                    if (splitThirdPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
//                    {
//                        string qualifier = "";
//                        for (int a = 0; a < splitThirdPart.GetUpperBound(0); a++)
//                        {
//                            if (a == (splitThirdPart.GetUpperBound(0) - 1))
//                                qualifier += splitThirdPart[a];
//                            else
//                                qualifier += splitThirdPart[a] + "_";
//                        }
//                        objClassTerm[4] = qualifier; //Associated Object Class Term Qualifier
//                        objClassTerm[5] = splitThirdPart[splitThirdPart.GetUpperBound(0)]; //Associated Object Class Term
//                    }
//                    else
//                        objClassTerm[4] = partsOfDEN[2]; //Representation Term


//                    ////split the third part of DEN
//                    //string[] splitThirdPart = null;
//                    //for (int i = 1; i < 3; i++)
//                    //{
//                    //    splitThirdPart = partsOfDEN[2].Split("_".ToCharArray(), i);
//                    //}
//                    //if (splitThirdPart.GetUpperBound(0) == 1)  // "property term qualifier" is exist
//                    //{
//                    //    objClassTerm[2] = splitThirdPart[0]; //property term qualifier
//                    //    objClassTerm[3] = splitThirdPart[1]; //Property Term
//                    //}
//                    //else
//                    //    objClassTerm[2] = partsOfDEN[2]; //Property Term

//                    ////Representation Term
//                    //objClassTerm[4] = partsOfDEN[1]; // second part of DEN
//                    break;
//                }
//            }
//            return objClassTerm;
//        }


//        private string[] SplitDEN(string dictEntryName)
//        {
//            string[] splitFirstPart = null;
//            string temp = dictEntryName;
//            int count = 1;
//            //as long the string still contain "_", we split it.
//            do
//            {
//                splitFirstPart = dictEntryName.Split("_".ToCharArray(), count); //split optional qualifier "_" from first part of ASBIE (target Name)
//                temp = splitFirstPart[count - 1];
//                count++;
//            } while (temp.Contains("_"));

//            return splitFirstPart;
//        }




//        /// <sUMM2ary>
//        /// Sets the cardinality of the element according to the information in the 
//        /// BasicBusinessInformationEntity
//        /// </sUMM2ary>
//        /// <param name="e1"></param>
//        /// <param name="abie"></param>
//        private void setBBIECardinality(XmlSchemaElement e1, EA.Attribute bbie)
//        {

//            //Set Lower Bound            
//            try
//            {
//                int lower = Int32.Parse(bbie.LowerBound);
//                e1.MinOccurs = lower;
//            }
//            catch (Exception e) { }

//            //Set Upper Bound
//            try
//            {
//                if (bbie.UpperBound == "*")
//                {
//                    e1.MaxOccursString = "unbounded";
//                }
//                else
//                {
//                    int upper = Int32.Parse(bbie.UpperBound);
//                    //We do not need to consider 1 as this is the default value
//                    if (upper != 1)
//                        e1.MaxOccurs = upper;
//                }
//            }
//            catch (Exception e) { }
//        }



//        /// <sUMM2ary>
//        /// Sets the type of the given bbie
//        /// If the type refers to a cdt/qdt the method first checks,
//        /// whether the relevant schema does already exist
//        /// If not the schema is created and a reference via import statement
//        /// is made
//        /// </sUMM2ary>
//        /// <param name="e"></param>
//        /// <param name="bbie"></param>
//        private void setBBIEType(XmlSchemaElement e, EA.Attribute bbie, XmlSchema schema, EA.Element element)
//        {
//            try
//            {
//                String type = bbie.Type;
//                int classifierID = bbie.ClassifierID;
//                EA.Element classifierElement = this.repository.GetElementByID(classifierID);
//                EA.Package classifierPackage = this.repository.GetPackageByID(classifierElement.PackageID);
//                String stereotype = classifierPackage.Element.Stereotype;
//                String s = "";

//                //if the generation is from any level generation
//                if (isAnyLevelGeneration)
//                {
//                    String sBLGen = "";
//                    if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(classifierPackage.Name)) != "")
//                    {
//                        #region for any level package generation, to check if there was previously generated schema
//                        ////We need to add an import statement for the newly generated schema
//                        ////to the original schema

//                        AuxilliarySchema aux = new AuxilliarySchema();
//                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
//                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));
//                        aux.PackageOfOrigin = classifierPackage.Name.ToString();

//                        String schemaName = "";
//                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

//                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, CC_Utils.blnAlias);

//                        addImport(schema, importPath, aux.Namespace);

//                        //We need to add the namespace of this schema to the main schema
//                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

//                        //Set the namespace to the variable which is then used down below
//                        s = aux.Namespace;

//                        //add the schema to local alreadyCreatedSchema
//                        this.alreadyCreatedSchemas.Add(aux);
//                        #endregion
//                    }
//                }

//                //Is this schema already included in local array?
//                if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "")
//                {
//                    if (!CC_Utils.blnLinkedSchema)
//                    {
//                        #region Include linked schema unchecked - for local generation only
//                        AuxilliarySchema aux = new AuxilliarySchema();
//                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
//                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));
//                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
//                        this.alreadyCreatedSchemas.Add(aux);

//                        String schemaName = "";
//                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

//                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, CC_Utils.blnAlias);

//                        addImport(schema, importPath, aux.Namespace);

//                        //We need to add the namespace of this schema to the main schema
//                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

//                        //Set the namespace to the variable which is then used down below
//                        s = aux.Namespace;
//                        #endregion
//                    }
//                    else
//                    {
//                        #region Included linked schema Checked
//                        //Create an Auxilliary schema and store it in the collection - later we have to
//                        //add it to the main schema collection
//                        AuxilliarySchema aux = new AuxilliarySchema();
//                        System.Collections.ICollection result = null;

//                        if (stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
//                        {
//                            result = new CDTGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(classifierPackage);
//                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "udt" + ++countUDTImports);
//                        }
//                        else if (stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
//                        {
//                            if (this.isAnyLevelGeneration)
//                            {
//                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
//                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
//                            }
//                            else
//                            {
//                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(classifierPackage);
//                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
//                            }
//                        }
//                        else if (stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
//                        {
//                            result = new ENUMGenerator(this.repository, classifierPackage.PackageID.ToString(), annotate, this.path, getCaller()).generateSchema(classifierPackage);
//                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "enum" + ++countENUMImports);
//                        }
//                        else
//                        {
//                            throw new XMLException("");
//                        }

//                        //We get the namespace for the newly created QDTLibrary-Schema from the package name
//                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
//                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
//                        aux.Schemas = result;

//                        //Add the name of the already-generated schema to local array
//                        this.alreadyCreatedSchemas.Add(aux);

//                        //Add the name of the already-generated schema to global array for any-level generation
//                        if (isAnyLevelGeneration)
//                            this.alreadyCreatedSchemasBLGen.Add(aux);

//                        String schemaPath = "";
//                        String schemaName = "";
//                        schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, CC_Utils.blnAlias);
//                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

//                        //Write the schema(s)
//                        foreach (XmlSchema schema1 in result)
//                        {

//                            //It is possible, that more than one schema is returned here (because the
//                            //auxilliary schemas may have interdependencies
//                            //write only the one where the namespace fits to the one we initally created
//                            if (schema1.TargetNamespace.Equals(aux.Namespace))
//                            {
//                                String filename = path + schemaPath + schemaName;
//                                //Create the path
//                                System.IO.Directory.CreateDirectory(path + schemaPath);
//                                Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
//                                schema1.Write(outputStream);
//                                outputStream.Close();
//                            }
//                        }

//                        //We need to add an import statement for the newly generated schema
//                        //to the original schema
//                        String importPath = XMLTools.getImportPathForSchema(classifierPackage, repository, schemaName, scope, CC_Utils.blnAlias);
//                        addImport(schema, importPath, aux.Namespace);
//                        //We need to add the namespace of this schema to the main schema
//                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);
//                        //Set the namespace to the variable which is then used down below
//                        s = aux.Namespace;
//                        #endregion
//                    }
//                }
                
//                e.SchemaTypeName = new XmlQualifiedName(bbie.Type + "Type", s);

//            }
//            catch (Exception ex)
//            {
//                this.appendWarnMessage("Unable to determine correct datatype for attribute " + bbie.Name + " in element " + element.Name + ". Taking xsd:string instead. ", this.getPackageName());
//                e.SchemaTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
//            }
//        }


//        /// <sUMM2ary>
//        /// Returns an empty String if the schema is not included
//        /// If the schema is included, the namespace is returned
//        /// </sUMM2ary>
//        /// <param name="packageName"></param>
//        /// <returns></returns>
//        private String isSchemaAlreadyIncluded(String packageName)
//        {
//            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemas)
//            {
//                if (aux.PackageOfOrigin == packageName)
//                    return aux.Namespace;
//            }
//            return "";
//        }



//        /// <sUMM2ary>
//        /// Add a new import to the schema
//        /// </sUMM2ary>
//        /// <param name="schema"></param>
//        private void addImport(XmlSchema schema, String schemaLocation, String namespace_)
//        {
//            XmlSchemaImport xsi1 = new XmlSchemaImport();
//            xsi1.SchemaLocation = schemaLocation;
//            xsi1.Namespace = namespace_;
//            schema.Includes.Add(xsi1);
//        }


//        /// <sUMM2ary>
//        /// Adds the necessary imports to the schema
//        /// </sUMM2ary>
//        /// <param name="schema"></param>
//        private void addImports(XmlSchema schema)
//        {
//            //nothing to do here so far
//        }



//        /// <sUMM2ary>
//        /// Adds the necessary Namespaces to the Schema
//        /// </sUMM2ary>
//        /// <param name="schema"></param>
//        private void addNameSpaces(XmlSchema schema)
//        {
//            string schemaNamespace = "";

//            schema.Namespaces.Add("xsd", "http://www.w3.org/2001/XMLSchema");
//            schema.Namespaces.Add("ccts", "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");

//            //Catch if the baseURN tagged value is empty
//            schemaNamespace = XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope)));
//            if (schemaNamespace == "")
//                throw new Exception("Please fill the 'baseURN' tagged value of the package. 'baseURN' can not be empty.");

//            schema.Namespaces.Add(XMLTools.getNameSpacePrefix(this.repository.GetPackageByID(Int32.Parse(this.scope)), this.TargetNameSpacePrefix), schemaNamespace);
//            schema.TargetNamespace = schemaNamespace;
//        }



//        



//        


//        /// <sUMM2ary>
//        /// Checks whether the passed element is in the same package as the acutal package we are operating on
//        /// </sUMM2ary>
//        /// <param name="e"></param>
//        /// <returns></returns>
//        private bool isInSamePackage(EA.Element e)
//        {
//            if (Int32.Parse(scope) == e.PackageID)
//                return true;
//            else
//                return false;
//        }

//        /// <sUMM2ary>
//        /// This methods determins, what should be passed to an auxilliary schema generator
//        /// If this class itself has already been called by another class, the calling class is passed
//        /// otherwise an instance of this class is passed
//        /// </sUMM2ary>
//        /// <returns></returns>
//        private GeneratorCallBackInterface getCaller()
//        {
//            if (this.caller == null)
//                return this;
//            else
//                return caller;
//        }




//        public String TargetNameSpacePrefix
//        {
//            get { return targetNameSpacePrefix; }
//            set { targetNameSpacePrefix = value; }
//        }

//        

//        private string isAlreadyInBLGenArray(string packageName)
//        {
//            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemasBLGen)
//            {
//                if (aux.PackageOfOrigin == packageName)
//                    return aux.Namespace;
//            }
//            return "";
//        }

//        private string DeterminePrefix(Package importPackage)
//        {
//            if (importPackage.Element.Stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
//                return "udt" + ++countUDTImports;
//            else
//            if (importPackage.Element.Stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
//                return "enum" + ++countENUMImports;
//            else
//            if (importPackage.Element.Stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
//                return "qdt" + ++countQDTImports;
//            else
//                throw new XMLException("");
//}
        #endregion

        #region kelas gabungan
        /// <sUMM2ary>
        /// Creates a Schema Element for the passed EA.Element
        /// </sUMM2ary>
        /// <param name="e"></param>
        /// <returns></returns>
        internal XmlSchemaComplexType getSchemaElement(EA.Element e, XmlSchema schema)
        {


            //Create an new ComplexType for the passed ABIE
            XmlSchemaComplexType complexType = new XmlSchemaComplexType();
            complexType.Name = XMLTools.getXMLName(e.Name) + "Type";
            XmlSchemaSequence sequence = new XmlSchemaSequence();

            if (!XMLTools.isElementAlreadyIncludedInSchema(schema, complexType.Name))
            {

                //Get the annotation
                if (this.annotate)
                    complexType.Annotation = getABIEAnnotation(e);

                #region get attribute

                ArrayList tempPostion = new ArrayList();
                ArrayList tempNoPostion = new ArrayList();

                foreach (EA.Attribute attr in e.Attributes)
                {
                    SearchAttributeForPositionTaggedValue(attr, tempPostion, tempNoPostion);
                }

                #endregion

                #region get aggregation

                //Now check, whether there are any ASBIEs
                //foreach (EA.Connector con in e.Connectors) --> change "foreach" to "for" (special for looping through EA collection) to avoid crash on release mode
                for (short idx=0; idx<e.Connectors.Count; idx++)
                {
                    EA.Connector con = (EA.Connector)e.Connectors.GetAt(idx);
                    if (con.Type == EA_Element.Aggregation.ToString() && con.Stereotype.ToString() == CCTS_Types.ASBIE.ToString()
                        && con.SupplierID == e.ElementID)
                    {
                        //Elements within the BIE library may have connectors which lead to DOCLibraries
                        //(because BIEs are used within DOCLibraries)
                        //Ignore such connectors                    
                        EA.ConnectorEnd clientEnd = con.ClientEnd;
                        EA.Element client = this.repository.GetElementByID(con.ClientID);
                        EA.Element supplier = this.repository.GetElementByID(con.SupplierID);

                        //Is the connection type an Aggregation or a Composition?
                        //A composition == 2
                        //bool isComposition = false;
                        //if (con.SupplierEnd.Aggregation == 2)
                        //{
                        //    isComposition = true;
                        //}
                        String elementName = "";

                        //If a role name is specified, we take the name of the
                        //role and create a new element from it (if it does not already exist)
                        //If a role name is specified, the name is
                        //Supplier.Name + Role.Name + Client.Name
                        if (clientEnd.Role != "")
                        {
                            elementName = XMLTools.getXMLName(clientEnd.Role + client.Name);
                        }
                        else
                        {
                            //If no role name is specified, the name is
                            //Supplier.Name + Client.Name
                            elementName = XMLTools.getXMLName(client.Name);
                        }


                        if (isInSamePackage(client))
                        {
                            //if (!isComposition) {
                            //    if (!XMLTools.isElementAlreadyIncludedInSchema(schema, elementName)) {
                            //        //We need to create a new element
                            //        XmlSchemaElement xel = new XmlSchemaElement();
                            //        xel.Name = elementName;
                            //        xel.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //        schema.Items.Add(xel);
                            //    }
                            //}

                            //Now add a reference to this element to the sequence
                            XmlSchemaElement elemRef = new XmlSchemaElement();

                            //Annotate?
                            if (this.annotate)
                                elemRef.Annotation = getASBIEAnnotation(con);

                            ////Set the cardinality of the element
                            setASBIECardinality(elemRef, clientEnd.Cardinality);

                            //If the association is a composition we have to declare the ASBIE
                            //locally

                            //aggregation or composition is treated the same way - for quick fix
                            //if (isComposition) {
                            elemRef.Name = elementName;
                            elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //}
                            //else {
                            //    elemRef.RefName = new XmlQualifiedName(elementName, XMLTools.getNameSpace(this.repository,this.repository.GetPackageByID(Int32.Parse(this.scope))));
                            //}

                            #region search for 'position' tagged value
                            //aggregation or composition is treated the same way - for quick fix
                            //if (isComposition)
                            SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

                            #endregion

                        }
                        //Not from this BIELibrary
                        else
                        {

                            //We only import other elements if they are located in a BIELibrary or CCLibrary
                            EA.Package p = this.repository.GetPackageByID(client.PackageID);
                            if (p.Element.Stereotype.Equals(CCTS_Types.BIELibrary.ToString()) || p.Element.Stereotype.Equals(CCTS_Types.CCLibrary.ToString()))
                            {

                                XmlQualifiedName qName = createAndImportAuxilliarySchema(client, schema);
                                XmlSchemaElement elemRef = new XmlSchemaElement();
                                //Annotate?
                                if (this.annotate)
                                    elemRef.Annotation = getASBIEAnnotation(con);

                                ////Set the cardinality of the element
                                setASBIECardinality(elemRef, clientEnd.Cardinality);

                                //If the association is a composition we have to declare the ASBIE
                                //locally
                                //aggregation or composition is treated the same way - for quick fix
                                //if (isComposition) {
                                elemRef.Name = elementName;
                                elemRef.SchemaTypeName = new XmlQualifiedName(XMLTools.getXMLName(client.Name) + "Type", XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(client.PackageID)));
                                //}
                                //else {
                                //    elemRef.RefName = qName;
                                //}

                                #region search for 'position' tagged value
                                //aggregation or composition is treated the same way - for quick fix
                                //if (isComposition)
                                SearchConnectorForPositionTaggedValue(con.TaggedValues, tempPostion, tempNoPostion, elemRef);

                                #endregion

                            }
                        }
                    }
                }

                #endregion

                #region Sort the BBIE and ASBIE
                //sort connector, then insert it into sequence
                SortByPosition comparerPosition = new SortByPosition();
                SortByName comparerName = new SortByName();

                tempPostion.Sort(comparerPosition);
                tempNoPostion.Sort(comparerName);

                //sort the element with "position" tagged value
                foreach (object obj in tempPostion)
                {
                    if (((ArrayList)obj)[2].ToString() == "Attribute")
                    {
                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                        if (attribute.Stereotype.Equals(CCTS_Types.BBIE.ToString()))
                        {
                            XmlSchemaElement attrElem = new XmlSchemaElement();
                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
                            //Set the type
                            setBBIEType(attrElem, attribute, schema, e);
                            //Set the cardinality
                            setBBIECardinality(attrElem, attribute);
                            //Get the annotation
                            if (this.annotate)
                                attrElem.Annotation = getBBIEAnnotation(attribute);
                            //check for lower cardinality, if lower bound = 0, add nillable attribute
                            if (getCaller().GetType() == typeof(DOCGenerator))
                            {
                                DOCGenerator theCaller = (DOCGenerator)getCaller();
                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }
                            else
                            {
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }

                            //Add the element to the sequence
                            sequence.Items.Add(attrElem);
                        }
                    }
                    else if (((ArrayList)obj)[2].ToString() == "Connector")
                    {
                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                        sequence.Items.Add(schemaElement);
                    }

                }

                //sort the element alphabetically
                foreach (object obj in tempNoPostion)
                {
                    if (((ArrayList)obj)[2].ToString() == "Attribute")
                    {
                        EA.Attribute attribute = (EA.Attribute)(((ArrayList)obj)[1]);
                        if (attribute.Stereotype.Equals(CCTS_Types.BBIE.ToString()))
                        {
                            XmlSchemaElement attrElem = new XmlSchemaElement();
                            attrElem.Name = XMLTools.getXMLName(attribute.Name);
                            //Set the type
                            setBBIEType(attrElem, attribute, schema, e);
                            //Set the cardinality
                            setBBIECardinality(attrElem, attribute);
                            //Get the annotation
                            if (this.annotate)
                                attrElem.Annotation = getBBIEAnnotation(attribute);

                            //check for lower cardinality, if lower bound = 0, add nillable attribute
                            if (getCaller().GetType() == typeof(DOCGenerator))
                            {
                                DOCGenerator theCaller = (DOCGenerator)getCaller();
                                if ((theCaller.blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }
                            else
                            {
                                if ((blnNillable == true) && (Int32.Parse(attribute.LowerBound) == 0))
                                    attrElem.IsNillable = true;
                            }

                            //Add the element to the sequence
                            sequence.Items.Add(attrElem);
                        }
                    }
                    else if (((ArrayList)obj)[2].ToString() == "Connector")
                    {
                        XmlSchemaElement schemaElement = (XmlSchemaElement)(((ArrayList)obj)[1]);
                        sequence.Items.Add(schemaElement);
                    }
                }

                //generate warning if there is a mix sort, alphabetically and sequence
                if ((tempPostion.Count > 0) && (tempNoPostion.Count > 0))
                    this.appendWarnMessage("There is a mix of sequence and alphabetic sorting of attributes (BBIEs) and aggregations (ASBIEs) in element " + e.Name, this.getPackageName());

                #endregion
            }

            complexType.Particle = sequence;

            return complexType;

        }

        /// <sUMM2ary>
        /// Search Connector with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the element with type XMLSchemaElement
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </sUMM2ary>
        /// <returns></returns>
        private void SearchConnectorForPositionTaggedValue(EA.Collection col, ArrayList tempPosition, ArrayList tempNoPosition, XmlSchemaElement elemRef)
        {
            bool isError = false;
            bool isPositionExist = false;


            //search for attribute's tagged value 'position'
            foreach (EA.ConnectorTag tagval in col)
            {
                //if "position" tagged value exist and has value
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != ""))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(elemRef);
                        temp.Add("Connector");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(elemRef.Name);
                temp.Add(elemRef);
                temp.Add("Connector");

                tempNoPosition.Add(temp);
            }
        }

        /// <sUMM2ary>
        /// Search Attribute with "position" tagged value
        /// if exist, sort by "position", then the rest sort alphabethically
        /// The Array tempPosition/tempNoPostion structure : 
        /// [0] value of "position" tagged value
        /// [1] the attribute with type EA.Attribute
        /// [2] type (Attribute or Connector)-> used for sorting
        /// </sUMM2ary>
        /// <returns></returns>
        //private  void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempAttr, ArrayList tempAttrWithPosition)
        private void SearchAttributeForPositionTaggedValue(EA.Attribute attr, ArrayList tempPosition, ArrayList tempNoPosition)
        {
            bool isError = false;
            bool isPositionExist = false;

            foreach (EA.AttributeTag tagval in attr.TaggedValues)
            {
                if ((tagval.Name.Equals("position", StringComparison.OrdinalIgnoreCase)) && (tagval.Value != null))
                {
                    ArrayList temp = new ArrayList();
                    isPositionExist = true;

                    try
                    {
                        //convert str to int,test if the value of tagged value is an integer
                        Convert.ToInt16(tagval.Value);
                    }
                    catch (Exception ex)
                    {
                        isError = true;
                        break;
                    }
                    if (!isError)
                    {
                        temp.Add(tagval.Value);
                        temp.Add(attr);
                        temp.Add("Attribute");

                        tempPosition.Add(temp);
                        break;
                    }
                }
            }

            if ((!isPositionExist) || ((isPositionExist) && (isError)))
            {
                ArrayList temp = new ArrayList();
                temp.Add(attr.Name);
                temp.Add(attr);
                temp.Add("Attribute");

                tempNoPosition.Add(temp);
            }
        }


        private XmlQualifiedName createAndImportAuxilliarySchema(EA.Element e, XmlSchema schema)
        {
            //Get the package of origin of the element
            EA.Package p = this.repository.GetPackageByID(e.PackageID);
            String pName = p.Name;
            String s = "";

            //if the generation is from any level generation
            if (isAnyLevelGeneration)
            {
                String sBLGen = "";
                //is the schema already included in global array?
                if ((s = isSchemaAlreadyIncluded(p.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(p.Name)) != "")
                {
                    #region for any level package generation, to check if there was previously generated schema
                    ////We need to add an import statement for the newly generated schema
                    ////to the original schema
                    ////if (different package than previously generated) and !(already included)

                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();

                    //String schemaPath = "";
                    String schemaName = "";
                    //schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository);
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
                    //String filename = path + schemaPath + schemaName;


                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnAlias);//CC_Utils.blnAlias);

                    determineImportOrInclude(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;

                    //add the schema to local alreadyCreatedSchema
                    this.alreadyCreatedSchemas.Add(aux);
                    #endregion
                }
            }

            //Is this schema already included?
            if ((s = isSchemaAlreadyIncluded(p.Name)) == "")
            {
                if (!this.blnIncludeLinkedSchema)//CC_Utils.blnLinkedSchema)
                {
                    #region Include linked schema unchecked - for particular generation only
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    aux.PackageOfOrigin = p.Name.ToString();
                    this.alreadyCreatedSchemas.Add(aux);

                    String schemaName = "";
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));

                    String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(p.PackageID), repository, schemaName, scope, this.blnAlias);

                    addImport(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;
                    #endregion
                }
                else
                {
                    #region Include linked schema checked

                    System.Collections.ICollection result = null;

                    if (p.Element.Stereotype == CCTS_Types.BIELibrary.ToString())
                    {
                        if (this.isAnyLevelGeneration)
                        {
                            result = new BIEGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                                this.blnAlias, this.blnNillable, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
                        }
                        else
                        {
                            result = new BIEGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                                this.blnAlias, this.blnNillable, this.path, getCaller()).generateSchema(p);
                        }
                    }
                    else if (p.Element.Stereotype == CCTS_Types.CCLibrary.ToString())
                    {
                        if (this.isAnyLevelGeneration)
                        {
                            result = new CCGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                                this.blnAlias, this.blnNillable, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(p);
                        }
                        else
                        {
                            result = new CCGenerator(this.repository, p.PackageID.ToString(), this.annotate, this.blnIncludeLinkedSchema,
                            this.blnAlias, this.blnNillable, this.path, getCaller()).generateSchema(p);
                        }
                    }
                    //Create an Auxilliary schema and store it in the collection - later we have to
                    //add it to the main schema collection
                    AuxilliarySchema aux = new AuxilliarySchema();
                    aux.Namespace = XMLTools.getNameSpace(this.repository, p);
                    //if (this.typeLibrary == typeLibraryEnum.BIELibrary.ToString())
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "bie" + ++countBIEImports);
                    //else
                    //    aux.NamespacePrefix = XMLTools.getNameSpacePrefix(p, "cc" + ++countBIEImports);

                    aux.PackageOfOrigin = p.Name.ToString();
                    aux.Schemas = result;

                    this.alreadyCreatedSchemas.Add(aux);

                    if (isAnyLevelGeneration)
                        this.alreadyCreatedSchemasBLGen.Add(aux);


                    String schemaPath = "";
                    String schemaName = "";
                    schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(p.PackageID), repository, this.blnAlias);
                    schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(p.PackageID));
                    String filename = path + schemaPath + schemaName;

                    //Write the schema(s)
                    foreach (XmlSchema schema1 in result)
                    {
                        //Create the path
                        System.IO.Directory.CreateDirectory(path + schemaPath);
                        Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                        schema1.Write(outputStream);
                        outputStream.Close();
                    }

                    //We need to add an import statement for the newly generated schema
                    //to the original schema
                    String importPath = XMLTools.getImportPathForSchema(p, repository, schemaName, scope, this.blnAlias);

                    //check whether it's "include" or "import"
                    determineImportOrInclude(schema, importPath, aux.Namespace);

                    //We need to add the namespace of this schema to the main schema
                    schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                    //Set the namespace to the variable which is then used down below
                    s = aux.Namespace;

                    #endregion
                }
            }

            return new XmlQualifiedName(e.Name + "Type", s);

        }

        private void determineImportOrInclude(XmlSchema schema, String schemaLocation, String namespace_)
        {
            if (schema.TargetNamespace == namespace_)
                addInclude(schema, schemaLocation, namespace_);
            else
                addImport(schema, schemaLocation, namespace_);
        }

        /// <sUMM2ary>
        /// Return the Annotation for a given ASBIE element
        /// </sUMM2ary>
        /// <param name="name"></param>
        /// <returns></returns>
        internal XmlSchemaAnnotation getASBIEAnnotation(EA.Connector con)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();

            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*Cardinality", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*PropertyTerm", 
                "*PropertyQualifierTerm", 
                "*AssociatedObjectClassTerm", 
                "*AssociatedObjectClassQualifierTerm", 
                "*AssociationType", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm",     
                "*Example",
                "*RepresentationLayout" //,
                //"*Notes"
            };

            String[] values = { XMLTools.getConnectorTVValue(CCTS_TV.UniqueID,con), 
                CCTS_Types.ASBIE.ToString(),  
                XMLTools.getConnectorTVValue(CCTS_TV.DictionaryEntryName,con), 
                XMLTools.getConnectorTVValue(CCTS_TV.Version,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.Definition,con), 
                getASBIECardinality(con.ClientEnd), 
                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.ObjectClassQualifierTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.PropertyTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.PropertyQualifierTerm,con),  
                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.AssociatedObjectClassQualifierTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.AssociationType,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.GeopoliticalOrRegionContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.OfficialConstraintContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.ProductContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.IndustryContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessProcessContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.SupportingRoleContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.SystemCapabilitiesContextValue,con),
                XMLTools.getConnectorTVValue(CCTS_TV.UsageRule,con),
                XMLTools.getConnectorTVValue(CCTS_TV.BusinessTerm,con),
                XMLTools.getConnectorTVValue(CCTS_TV.Example,con),
                XMLTools.getConnectorTVValue(CCTS_TV.RepresentationLayout,con)//,
                //con.Notes
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }


        /// <sUMM2ary>
        /// Return the ASBIE Cardinality
        /// </sUMM2ary>
        /// <param name="clientEnd"></param>
        /// <returns></returns>
        private String getASBIECardinality(EA.ConnectorEnd clientEnd)
        {

            if (clientEnd.Cardinality == "")
                return "1";
            else
                return clientEnd.Cardinality;
        }


        /// <sUMM2ary>
        /// Sets the cardinality of the element according to the information in the 
        /// AggregateBusinessInformationEntity
        /// This proves to be a little bit more tricky than with the BCC because we
        /// receive only one String containing both, the upper and the lower bound
        /// </sUMM2ary>
        /// <param name="e1"></param>
        /// <param name="abie"></param>
        internal void setASBIECardinality(XmlSchemaElement e1, String c)
        {

            String lower = "";
            String upper = "";
            try
            {
                //Try to split up the String
                String cardinality = c;
                lower = cardinality.Substring(0, 1);
                upper = cardinality.Substring(3);
            }
            catch { }

            try
            {
                //Try to set the lower
                int i = Int32.Parse(lower);
                e1.MinOccurs = i;
            }
            catch { }

            try
            {
                //Try to set the upper
                if (upper == "*")
                    e1.MaxOccursString = "unbounded";
                else
                {
                    int i = Int32.Parse(upper);
                    if (i != 1)
                        e1.MaxOccurs = i;
                }
            }
            catch { }

        }


        /// <sUMM2ary>
        /// Return the Annotation for a given ABIE element
        /// </sUMM2ary>
        /// <param name="name"></param>
        /// <returns></returns>
        private XmlSchemaAnnotation getABIEAnnotation(EA.Element abie)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();
            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm", 
                "*Example",
                "*RepresentationLayout"//,
                //"*Notes"
            };

            //Get ObjectClassTerm & ObjectClassQualifierTerm
            string[] objClassTerm = GetObjectClassTerm(abie);

            String[] values = { XMLTools.getElementTVValue(CCTS_TV.UniqueID, abie), 
                CCTS_Types.ABIE.ToString(),
                XMLTools.getElementTVValue(CCTS_TV.DictionaryEntryName, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Version, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Definition, abie),
                objClassTerm[1] != null ? objClassTerm[1] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassTerm, abie), 
                objClassTerm[0] != null ? objClassTerm[0] : "", //XMLTools.getElementTVValue(CCTS_TV.ObjectClassQualifierTerm, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, abie),                  
                XMLTools.getElementTVValue(CCTS_TV.OfficialConstraintContextValue, abie),                
                XMLTools.getElementTVValue(CCTS_TV.ProductContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.IndustryContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessProcessRoleContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.SupportingRoleContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.SystemCapabilitiesContextValue, abie), 
                XMLTools.getElementTVValue(CCTS_TV.UsageRule, abie), 
                XMLTools.getElementTVValue(CCTS_TV.BusinessTerm, abie), 
                XMLTools.getElementTVValue(CCTS_TV.Example, abie),
                XMLTools.getElementTVValue(CCTS_TV.RepresentationLayout, abie)//,
                //abie.Notes
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }

        private string[] GetObjectClassTerm(Element abie)
        {
            string[] objClassTerm = new string[2];
            foreach (EA.TaggedValue tg in abie.TaggedValues)
            {
                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
                {
                    string dict = tg.Value;
                    string[] partsOfDEN = null;

                    //split the Dictionary Entry Name into three part
                    for (int i = 1; i < 4; i++)
                    {
                        partsOfDEN = dict.Split(".".ToCharArray(), i);
                    }

                    string[] splitFirstPart = null;
                    //split the first part of DEN
                    for (int i = 1; i < 3; i++)
                    {
                        splitFirstPart = partsOfDEN[0].Split("_".ToCharArray(), i);
                    }
                    if (splitFirstPart.GetUpperBound(0) == 1)  // "object class term qualifier" is exist
                    {
                        objClassTerm[0] = splitFirstPart[0]; //object class term qualifier
                        objClassTerm[1] = splitFirstPart[1]; //Object Class Term
                    }
                    else
                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term

                    break;
                }
            }
            return objClassTerm;
        }


        /// <sUMM2ary>
        /// Return the Annotation for a given BBIE element
        /// </sUMM2ary>
        /// <returns></returns>
        internal XmlSchemaAnnotation getBBIEAnnotation(EA.Attribute bcc)
        {
            XmlSchemaAnnotation ann = new XmlSchemaAnnotation();
            XmlSchemaDocumentation doc = new XmlSchemaDocumentation();
            doc.Language = "en";

            XmlDocument xml = new XmlDocument();

            String card = bcc.LowerBound + ".." + bcc.UpperBound;
            //These arrays hold the names and the values of the annotation
            String[] nodes = { "*UniqueID", 
                "*Acronym", 
                "*DictionaryEntryName", 
                "*Version", 
                "*Definition", 
                "*Cardinality", 
                "*ObjectClassTerm", 
                "*ObjectClassQualifierTerm", 
                "*PropertyTerm", 
                "*PropertyQualifierTerm", 
                "*PrimaryRepresentationTerm", 
                "*BusinessProcessContextValue", 
                "*GeopoliticalOrRegionContextValue", 
                "*OfficialConstraintContextValue", 
                "*ProductContextValue", 
                "*IndustryContextValue", 
                "*BusinessProcessRoleContextValue", 
                "*SupportingRoleContextValue", 
                "*SystemCapabilitiesContextValue", 
                "*UsageRule", 
                "*BusinessTerm", 
                "*Example",
                "*RepresentationLayout"//,
                //"*Notes"
            };

            //Get ObjectClassTerm & ObjectClassQualifierTerm
            string[] objClassTerm = GetObjectClassTermBBIE(bcc);

            String[] values = { XMLTools.getAttributeTVValue(CCTS_TV.UniqueID, bcc), 
                CCTS_Types.BBIE.ToString(), 
                XMLTools.getAttributeTVValue(CCTS_TV.DictionaryEntryName, bcc), 
                XMLTools.getAttributeTVValue(CCTS_TV.Version, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.Definition, bcc), 
                card, 
                objClassTerm != null ? (objClassTerm[1] != null ? objClassTerm[1] : "") : "" ,//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassTerm, bbie), 
                objClassTerm != null ? (objClassTerm[0] != null ? objClassTerm[0] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.ObjectClassQualifierTerm, bbie), 
                objClassTerm != null ? (objClassTerm[3] != null ? objClassTerm[3] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyTerm, bbie), 
                objClassTerm != null ? (objClassTerm[2] != null ? objClassTerm[2] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PropertyQualifierTerm, bbie),
                objClassTerm != null ? (objClassTerm[4] != null ? objClassTerm[4] : "") : "",//XMLTools.getAttributeTVValue(CCTS_TV.PrimaryRepresentationTerm, bbie),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.GeopoliticalOrRegionContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.OfficialConstraintContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.ProductContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.IndustryContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessProcessContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.SupportingRoleContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.SystemCapabilitiesContextValue, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.UsageRule, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.BusinessTerm, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.Example, bcc),
                XMLTools.getAttributeTVValue(CCTS_TV.RepresentationLayout, bcc)//,
                //bbie.Notes
                
            };

            XmlNode[] annNodes = new XmlNode[nodes.Length];
            for (int i = 0; i < nodes.Length; i++)
            {
                //If a node is optional (a node is optional if its name starts with a *)
                //we only include it, if a value is specified
                bool include = true;
                if (nodes[i].Substring(0, 1) == "*" && values[i] == "")
                {
                    include = false;
                }
                if (include)
                {
                    XmlNode node = xml.CreateElement("ccts", nodes[i].Replace("*", ""), "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");
                    if (values[i] != "")
                        node.InnerText = values[i];
                    annNodes[i] = node;
                }
            }

            doc.Markup = annNodes;
            ann.Items.Add(doc);

            return ann;
        }

        private string[] GetObjectClassTermBBIE(EA.Attribute bbie)
        {
            string[] objClassTerm = new string[6];
            foreach (EA.AttributeTag tg in bbie.TaggedValues)
            {
                if (tg.Name.Equals(CCTS_TV.DictionaryEntryName.ToString(), StringComparison.OrdinalIgnoreCase) && (tg.Value != ""))
                {
                    string dict = tg.Value;
                    string[] partsOfDEN = null;

                    //split the Dictionary Entry Name into three part
                    for (int i = 1; i < 4; i++)
                    {
                        partsOfDEN = dict.Split(".".ToCharArray(), i);
                    }

                    if (partsOfDEN.GetUpperBound(0) != 2)  //if the DEN doesn't have correct parts. The correct DEN must have 3 parts.
                        return null;

                    //split first part of DEN
                    string[] splitFirstPart = null;
                    splitFirstPart = SplitDEN(partsOfDEN[0]);

                    if (splitFirstPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitFirstPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitFirstPart.GetUpperBound(0) - 1))
                                qualifier += splitFirstPart[a];
                            else
                                qualifier += splitFirstPart[a] + "_";
                        }
                        objClassTerm[0] = qualifier; //object class term qualifier
                        objClassTerm[1] = splitFirstPart[splitFirstPart.GetUpperBound(0)]; //Object Class Term
                    }
                    else
                        objClassTerm[0] = partsOfDEN[0]; //Object Class Term


                    //split second part of DEN
                    string[] splitSecondPart = null;
                    splitSecondPart = SplitDEN(partsOfDEN[1]);

                    if (splitSecondPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitSecondPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitSecondPart.GetUpperBound(0) - 1))
                                qualifier += splitSecondPart[a];
                            else
                                qualifier += splitSecondPart[a] + "_";
                        }
                        objClassTerm[2] = qualifier; //property term qualifier
                        objClassTerm[3] = splitSecondPart[splitSecondPart.GetUpperBound(0)]; //Property Term
                    }
                    else
                        objClassTerm[2] = partsOfDEN[1]; //Object Class Term

                    //split third part of DEN
                    string[] splitThirdPart = null;
                    splitThirdPart = SplitDEN(partsOfDEN[2]);

                    if (splitThirdPart.GetUpperBound(0) >= 1)  // "object class term qualifier" is exist
                    {
                        string qualifier = "";
                        for (int a = 0; a < splitThirdPart.GetUpperBound(0); a++)
                        {
                            if (a == (splitThirdPart.GetUpperBound(0) - 1))
                                qualifier += splitThirdPart[a];
                            else
                                qualifier += splitThirdPart[a] + "_";
                        }
                        objClassTerm[4] = qualifier; //Associated Object Class Term Qualifier
                        objClassTerm[5] = splitThirdPart[splitThirdPart.GetUpperBound(0)]; //Associated Object Class Term
                    }
                    else
                        objClassTerm[4] = partsOfDEN[2]; //Representation Term


                    ////split the third part of DEN
                    //string[] splitThirdPart = null;
                    //for (int i = 1; i < 3; i++)
                    //{
                    //    splitThirdPart = partsOfDEN[2].Split("_".ToCharArray(), i);
                    //}
                    //if (splitThirdPart.GetUpperBound(0) == 1)  // "property term qualifier" is exist
                    //{
                    //    objClassTerm[2] = splitThirdPart[0]; //property term qualifier
                    //    objClassTerm[3] = splitThirdPart[1]; //Property Term
                    //}
                    //else
                    //    objClassTerm[2] = partsOfDEN[2]; //Property Term

                    ////Representation Term
                    //objClassTerm[4] = partsOfDEN[1]; // second part of DEN
                    break;
                }
            }
            return objClassTerm;
        }


        private string[] SplitDEN(string dictEntryName)
        {
            string[] splitFirstPart = null;
            string temp = dictEntryName;
            int count = 1;
            //as long the string still contain "_", we split it.
            do
            {
                splitFirstPart = dictEntryName.Split("_".ToCharArray(), count); //split optional qualifier "_" from first part of ASBIE (target Name)
                temp = splitFirstPart[count - 1];
                count++;
            } while (temp.Contains("_"));

            return splitFirstPart;
        }


        /// <sUMM2ary>
        /// Sets the cardinality of the element according to the information in the 
        /// BasicBusinessInformationEntity
        /// </sUMM2ary>
        /// <param name="e1"></param>
        /// <param name="abie"></param>
        private void setBBIECardinality(XmlSchemaElement e1, EA.Attribute bbie)
        {

            //Set Lower Bound            
            try
            {
                int lower = Int32.Parse(bbie.LowerBound);
                e1.MinOccurs = lower;
            }
            catch (Exception e) { }

            //Set Upper Bound
            try
            {
                if (bbie.UpperBound == "*")
                {
                    e1.MaxOccursString = "unbounded";
                }
                else
                {
                    int upper = Int32.Parse(bbie.UpperBound);
                    //We do not need to consider 1 as this is the default value
                    if (upper != 1)
                        e1.MaxOccurs = upper;
                }
            }
            catch (Exception e) { }
        }



        /// <sUMM2ary>
        /// Sets the type of the given bbie
        /// If the type refers to a cdt/qdt the method first checks,
        /// whether the relevant schema does already exist
        /// If not the schema is created and a reference via import statement
        /// is made
        /// </sUMM2ary>
        /// <param name="e"></param>
        /// <param name="bbie"></param>
        private void setBBIEType(XmlSchemaElement e, EA.Attribute bbie, XmlSchema schema, EA.Element element)
        {
            try
            {

                String type = bbie.Type;
                int classifierID = bbie.ClassifierID;
                if (classifierID == 0)
                {
                    throw new Exception("Can't find classifier ID for <<" + CCTS_Types.BBIE.ToString() + ">>" + bbie.Name
                        + " of <<" + CCTS_Types.ABIE.ToString() + ">>" + element.Name);
                }

                EA.Element classifierElement = this.repository.GetElementByID(classifierID);
                EA.Package classifierPackage = this.repository.GetPackageByID(classifierElement.PackageID);
                String stereotype = classifierPackage.Element.Stereotype;
                String s = "";

                //if the generation is from any level generation
                if (isAnyLevelGeneration)
                {
                    String sBLGen = "";
                    if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "" && (sBLGen = isAlreadyInBLGenArray(classifierPackage.Name)) != "")
                    {
                        #region for any level package generation, to check if there was previously generated schema
                        ////We need to add an import statement for the newly generated schema
                        ////to the original schema

                        AuxilliarySchema aux = new AuxilliarySchema();
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));//"cc" + ++countBIEImports);
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();

                        String schemaName = "";
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnAlias);

                        determineImportOrInclude(schema, importPath, aux.Namespace);

                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;

                        //add the schema to local alreadyCreatedSchema
                        this.alreadyCreatedSchemas.Add(aux);
                        #endregion
                    }
                }

                //Is this schema already included in local array?
                if ((s = isSchemaAlreadyIncluded(classifierPackage.Name)) == "")
                {
                    if (!this.blnIncludeLinkedSchema) //CC_Utils.blnLinkedSchema)
                    {
                        #region "Include linked schema unchecked - for local generation only"
                        ////PRIMLibrary, how to handle?? 25 Sept 08
                        if (!(classifierPackage.Element.Stereotype == CCTS_Types.ENUMLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.DOCLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.CDTLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.QDTLibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.BIELibrary.ToString() |
                            classifierPackage.Element.Stereotype == CCTS_Types.CCLibrary.ToString()
                            ))
                        {
                            throw new XMLException("Schema generation from package with stereotype " + stereotype + " is not supported.");
                        }

                        AuxilliarySchema aux = new AuxilliarySchema();
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, DeterminePrefix(classifierPackage));
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
                        this.alreadyCreatedSchemas.Add(aux);

                        String schemaName = "";
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        String importPath = XMLTools.getImportPathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, schemaName, scope, this.blnAlias);

                        determineImportOrInclude(schema, importPath, aux.Namespace);

                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);

                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;
                        #endregion
                    }
                    else
                    {
                        #region Included linked schema
                        //Create an Auxilliary schema and store it in the collection - later we have to
                        //add it to the main schema collection
                        AuxilliarySchema aux = new AuxilliarySchema();
                        System.Collections.ICollection result = null;

                        if (stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                        {
                            result = new CDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "udt" + ++countUDTImports);
                        }
                        else if (stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                        {
                            if (this.isAnyLevelGeneration)
                            {//if anylevel generation, we should give schema saving path
                                //result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.blnAlias,
                                    this.blnIncludeLinkedSchema, this.path, this.alreadyCreatedSchemasBLGen).generateSchema(classifierPackage);
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                            }
                            else
                            {
                                result = new QDTGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, 
                                    this.blnIncludeLinkedSchema,this.blnAlias, this.path, getCaller()).generateSchema(classifierPackage);
                                //add checked option to QDTGenerator param blnAlias, blnIncludeLinkedSchema
                                aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "qdt" + ++countQDTImports);
                            }
                        }
                        else if (stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                        {
                            result = new ENUMGenerator(this.repository, classifierPackage.PackageID.ToString(), this.annotate, this.path, getCaller()).generateSchema(classifierPackage);
                            aux.NamespacePrefix = XMLTools.getNameSpacePrefix(classifierPackage, "enum" + ++countENUMImports);
                        }
                        else
                        {
                            throw new XMLException("Schema generation from package with stereotype " + stereotype + " is not supported.");
                        }

                        //We get the namespace for the newly created QDTLibrary-Schema from the package name
                        aux.Namespace = XMLTools.getNameSpace(this.repository, classifierPackage);
                        aux.PackageOfOrigin = classifierPackage.Name.ToString();
                        aux.Schemas = result;

                        //Add the name of the already-generated schema to local array
                        this.alreadyCreatedSchemas.Add(aux);

                        //Add the name of the already-generated schema to global array for any-level generation
                        if (isAnyLevelGeneration)
                            this.alreadyCreatedSchemasBLGen.Add(aux);

                        String schemaPath = "";
                        String schemaName = "";
                        schemaPath = XMLTools.getSavePathForSchema(this.repository.GetPackageByID(classifierPackage.PackageID), repository, this.blnAlias);
                        schemaName = XMLTools.getSchemaName(this.repository.GetPackageByID(classifierPackage.PackageID));

                        //Write the schema(s)
                        foreach (XmlSchema schema1 in result)
                        {
                            //It is possible, that more than one schema is returned here (because the
                            //auxilliary schemas may have interdependencies
                            //write only the one where the namespace fits to the one we initally created
                            if (schema1.TargetNamespace.Equals(aux.Namespace))
                            {
                                String filename = path + schemaPath + schemaName;
                                //Create the path
                                System.IO.Directory.CreateDirectory(path + schemaPath);
                                Stream outputStream = System.IO.File.Open(filename, FileMode.Create);
                                schema1.Write(outputStream);
                                outputStream.Close();
                            }
                        }

                        //We need to add an import statement for the newly generated schema
                        //to the original schema
                        String importPath = XMLTools.getImportPathForSchema(classifierPackage, repository, schemaName, scope, this.blnAlias);
                        determineImportOrInclude(schema, importPath, aux.Namespace);
                        //We need to add the namespace of this schema to the main schema
                        schema.Namespaces.Add(aux.NamespacePrefix, aux.Namespace);
                        //Set the namespace to the variable which is then used down below
                        s = aux.Namespace;
                        #endregion
                    }
                }

                e.SchemaTypeName = new XmlQualifiedName(bbie.Type + "Type", s);


            }
            catch (Exception ex)
            {
                this.appendWarnMessage("Unable to determine correct datatype for attribute " + bbie.Name + " in element " + element.Name + " caused by this error : " + ex.Message + "\n Taking xsd:string instead. ", this.getPackageName());
                e.SchemaTypeName = new XmlQualifiedName("string", "http://www.w3.org/2001/XMLSchema");
            }


        }

        private System.Collections.ICollection GetSchemaAlreadyCreated(string packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemas)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Schemas;
            }
            return null;
        }


        /// <sUMM2ary>
        /// Returns an empty String if the schema is not included
        /// If the schema is included, the namespace is returned
        /// </sUMM2ary>
        /// <param name="packageName"></param>
        /// <returns></returns>
        private String isSchemaAlreadyIncluded(String packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemas)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }



        /// <sUMM2ary>
        /// Add a new import to the schema
        /// </sUMM2ary>
        /// <param name="schema"></param>
        internal void addImport(XmlSchema schema, String schemaLocation, String namespace_)
        {
            XmlSchemaImport xsi1 = new XmlSchemaImport();
            xsi1.SchemaLocation = schemaLocation;
            xsi1.Namespace = namespace_;
            schema.Includes.Add(xsi1);
        }

        /// <sUMM2ary>
        /// Add a new import to the schema
        /// </sUMM2ary>
        /// <param name="schema"></param>
        internal void addInclude(XmlSchema schema, String schemaLocation, String namespace_)
        {
            XmlSchemaInclude xsi1 = new XmlSchemaInclude();
            xsi1.SchemaLocation = schemaLocation;
            //xsi1.Namespaces. = namespace_;
            schema.Includes.Add(xsi1);
        }




        /// <sUMM2ary>
        /// Adds the necessary Namespaces to the Schema
        /// </sUMM2ary>
        /// <param name="schema"></param>
        internal void addNameSpaces(XmlSchema schema)
        {
            string schemaNamespace = "";

            schema.Namespaces.Add("xsd", "http://www.w3.org/2001/XMLSchema");
            schema.Namespaces.Add("ccts", "urn:un:unece:uncefact:documentation:standard:CoreComponentsTechnicalSpecification:2");

            //Catch if the baseURN tagged value is empty
            schemaNamespace = XMLTools.getNameSpace(this.repository, this.repository.GetPackageByID(Int32.Parse(this.scope)));
            if (schemaNamespace == "")
                throw new Exception("Please fill the 'baseURN' tagged value of the package. 'baseURN' tagged value can not be empty.");

            schema.Namespaces.Add(XMLTools.getNameSpacePrefix(this.repository.GetPackageByID(Int32.Parse(this.scope)), this.TargetNameSpacePrefix), schemaNamespace);
            schema.TargetNamespace = schemaNamespace;
        }


        /// <sUMM2ary>
        /// Checks whether the passed element is in the same package as the acutal package we are operating on
        /// </sUMM2ary>
        /// <param name="e"></param>
        /// <returns></returns>
        private bool isInSamePackage(EA.Element e)
        {
            if (Int32.Parse(scope) == e.PackageID)
                return true;
            else
                return false;
        }

        /// <sUMM2ary>
        /// This methods determins, what should be passed to an auxilliary schema generator
        /// If this class itself has already been called by another class, the calling class is passed
        /// otherwise an instance of this class is passed
        /// </sUMM2ary>
        /// <returns></returns>
        private GeneratorCallBackInterface getCaller()
        {
            if (this.caller == null)
                return this;
            else
                return caller;
        }


        private String TargetNameSpacePrefix
        {
            get { return targetNameSpacePrefix; }
            set { targetNameSpacePrefix = value; }
        }

        private string isAlreadyInBLGenArray(string packageName)
        {
            foreach (AuxilliarySchema aux in this.alreadyCreatedSchemasBLGen)
            {
                if (aux.PackageOfOrigin == packageName)
                    return aux.Namespace;
            }
            return "";
        }

        private string DeterminePrefix(Package importPackage)
        {
            if (importPackage.Element.Stereotype.Equals(CCTS_Types.CDTLibrary.ToString()))
                return "udt" + ++countUDTImports;
            else
                if (importPackage.Element.Stereotype.Equals(CCTS_Types.ENUMLibrary.ToString()))
                    return "enum" + ++countENUMImports;
                else
                    if (importPackage.Element.Stereotype.Equals(CCTS_Types.QDTLibrary.ToString()))
                        return "qdt" + ++countQDTImports;
                    else
                        throw new XMLException("");

            //return "";
        }
        #endregion
    }
}