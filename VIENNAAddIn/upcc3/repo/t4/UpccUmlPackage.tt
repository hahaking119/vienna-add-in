<#@ assembly name="VIENNAAddInUtils.dll" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="VIENNAAddInUtils"#>
<#@ import namespace="VIENNAAddInUtils.t4"#>
<# 
	var library = metaPackage.Name.FirstCharToLowerCase();
#>
<#@ include file="t4/CctsRepositoryNamespaces.tt" #>
using System.Collections.Generic;
using VIENNAAddIn.upcc3.ccts.util;
using VIENNAAddIn.upcc3.uml;

namespace VIENNAAddIn.upcc3.repo
{
    internal <#= extendManually ? "partial " : "" #>class Upcc<#= metaPackage.Name #> : I<#= metaPackage.Name #>
    {
        private readonly IUmlPackage umlPackage;

        public Upcc<#= metaPackage.Name #>(IUmlPackage umlPackage)
        {
            this.umlPackage = umlPackage;
        }

        #region I<#= metaPackage.Name #> Members

		/// <summary>
		/// The <#= metaPackage.Stereotype #>'s unique ID.
		/// </summary>
        public int Id
        {
            get { return umlPackage.Id; }
        }

		/// <summary>
		/// The <#= metaPackage.Stereotype #>'s name.
		/// </summary>
        public string Name
        {
            get { return umlPackage.Name; }
        }
<#
///==========================================================================================================================
/// Parent packages
///==========================================================================================================================

		foreach (var relation in MetaModel.GetParentPackageRelationsFor(metaPackage))
		{
#>

		/// <summary>
		/// The <#= relation.ParentPackageType.Stereotype #> containing this <#= metaPackage.Stereotype #>.
		/// </summary>
		public I<#= relation.ParentPackageType.Name #> <#= relation.ParentPackageRole #>
        {
            get { return new Upcc<#= relation.ParentPackageType.Name #>(umlPackage.Parent); }
        }
<#
		}

///==========================================================================================================================
/// Sub-packages
///==========================================================================================================================

		foreach (var relation in MetaModel.GetSubPackageRelationsFor(metaPackage))
		{
			var subPackage = relation.SubPackageType.Stereotype;
			var subPackageParamName = relation.SubPackageType.Name.FirstCharToLowerCase();
#>

		/// <summary>
		/// The <#= subPackage #>s contained in this <#= metaPackage.Stereotype #>.
		/// </summary>
		public IEnumerable<I<#= relation.SubPackageType.Name #>> Get<#= relation.SubPackageRole #>()
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Retrieves a <#= subPackage #> by name.
		/// <param name="name">A <#= subPackage #>'s name.</param>
		/// <returns>The <#= subPackage #> with the given <paramref name="name"/> or <c>null</c> if no such <#= subPackage #> is found.</returns>
		/// </summary>
        public I<#= relation.SubPackageType.Name #> Get<#= relation.SubPackageType.Name #>ByName(string name)
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Creates a <#= subPackage #> based on the given <paramref name="specification"/>.
		/// <param name="specification">A specification for a <#= subPackage #>.</param>
		/// <returns>The newly created <#= subPackage #>.</returns>
		/// </summary>
		public I<#= relation.SubPackageType.Name #> Create<#= relation.SubPackageType.Name #>(<#= relation.SubPackageType.Name #>Spec specification)
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Updates a <#= subPackage #> to match the given <paramref name="specification"/>.
		/// <param name="<#= subPackageParamName #>">A <#= subPackage #>.</param>
		/// <param name="specification">A new specification for the given <#= subPackage #>.</param>
		/// <returns>The updated <#= subPackage #>. Depending on the implementation, this might be the same updated instance or a new instance!</returns>
		/// </summary>
        public I<#= relation.SubPackageType.Name #> Update<#= relation.SubPackageType.Name #>(I<#= relation.SubPackageType.Name #> <#= subPackageParamName #>, <#= relation.SubPackageType.Name #>Spec specification)
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// Removes a <#= subPackage #> from this <#= metaPackage.Stereotype #>.
		/// <param name="<#= subPackageParamName #>">A <#= subPackage #>.</param>
		/// </summary>
        public void Remove<#= relation.SubPackageType.Name #>(I<#= relation.SubPackageType.Name #> <#= subPackageParamName #>)
		{
			throw new NotImplementedException();
		}
<#
		}
		
///==========================================================================================================================
/// Classifiers
///==========================================================================================================================

		foreach (var relation in MetaModel.GetClassifierRelationsFor(metaPackage))
		{
			var element = relation.ClassifierType.Stereotype;
			var classifierType = relation.ClassifierType.Name;
			var classifier = classifierType.FirstCharToLowerCase();
			if (classifier == "enum") classifier = "@enum"; // dirty hack to avoid naming conflict with 'enum'
			var umlClassifierType = relation.ClassifierType.GetType().Name.Substring(4);
			var umlClassifier = "uml" + umlClassifierType.FirstCharToLowerCase();
#>

        private static Uml<#= umlClassifierType #>Spec <#= classifierType #>SpecToUml<#= umlClassifierType #>Spec(<#= classifierType #>Spec <#= classifier #>Spec)
        {
            return new Uml<#= umlClassifierType #>Spec
                   {
                       Name = <#= classifier #>Spec.Name,
                       TaggedValues = new[]
                                      {
<# 
		foreach (var metaTaggedValue in relation.ClassifierType.TaggedValues)
		{
#>
										  new UmlTaggedValueSpec("<#= metaTaggedValue.Name #>", <#= classifier #>Spec.<#= metaTaggedValue.AsPropertyName() #>),
<# 
		}
#>
									  },
                   };
        }

		/// <summary>
		/// The <#= element #>s contained in this <#= metaPackage.Stereotype #>.
		/// </summary>
		public IEnumerable<I<#= classifierType #>> <#= classifierType.Plural() #>
		{
            get
            {
                foreach (var <#= umlClassifier #> in umlPackage.<#= umlClassifierType.Plural() #>)
                {
                    yield return new Upcc<#= classifierType #>(<#= umlClassifier #>);
                }
            }
		}

		/// <summary>
		/// Retrieves a <#= element #> by name.
		/// <param name="name">A <#= element #>'s name.</param>
		/// <returns>The <#= element #> with the given <paramref name="name"/> or <c>null</c> if no such <#= element #> is found.</returns>
		/// </summary>
        public I<#= classifierType #> Get<#= classifierType #>ByName(string name)
		{
            foreach (I<#= classifierType #> <#= classifier #> in <#= classifierType.Plural() #>)
            {
                if (<#= classifier #>.Name == name)
                {
                    return <#= classifier #>;
                }
            }
            return null;
		}

		/// <summary>
		/// Creates a <#= element #> based on the given <paramref name="specification"/>.
		/// <param name="specification">A specification for a <#= element #>.</param>
		/// <returns>The newly created <#= element #>.</returns>
		/// </summary>
		public I<#= classifierType #> Create<#= classifierType #>(<#= classifierType #>Spec specification)
		{
		    return new Upcc<#= classifierType #>(umlPackage.Create<#= umlClassifierType #>(<#= classifierType #>SpecToUml<#= umlClassifierType #>Spec(specification)));
		}

		/// <summary>
		/// Updates a <#= element #> to match the given <paramref name="specification"/>.
		/// <param name="<#= classifier #>">A <#= element #>.</param>
		/// <param name="specification">A new specification for the given <#= element #>.</param>
		/// <returns>The updated <#= element #>. Depending on the implementation, this might be the same updated instance or a new instance!</returns>
		/// </summary>
        public I<#= classifierType #> Update<#= classifierType #>(I<#= classifierType #> <#= classifier #>, <#= classifierType #>Spec specification)
		{
		    return new Upcc<#= classifierType #>(umlPackage.Update<#= umlClassifierType #>(((Upcc<#= classifierType #>) <#= classifier #>).Uml<#= umlClassifierType #>, <#= classifierType #>SpecToUml<#= umlClassifierType #>Spec(specification)));
		}

		/// <summary>
		/// Removes a <#= element #> from this <#= metaPackage.Stereotype #>.
		/// <param name="<#= classifier #>">A <#= element #>.</param>
		/// </summary>
        public void Remove<#= relation.ClassifierType.Name #>(I<#= relation.ClassifierType.Name #> <#= classifier #>)
		{
            umlPackage.Remove<#= umlClassifierType #>(((Upcc<#= classifierType #>) <#= classifier #>).Uml<#= umlClassifierType #>);
		}
<#
		}

///==========================================================================================================================
/// Tagged Values
///==========================================================================================================================

		foreach (var metaTaggedValue in metaPackage.TaggedValues)
		{
#>

        ///<summary>
        /// Tagged value '<#= metaTaggedValue.Name #>'.
        ///</summary>
        public <#= metaTaggedValue.Cardinality == MetaCardinality.Many ? "IEnumerable<string>" : "string" #> <#= metaTaggedValue.AsPropertyName() #>
        {
            get { return umlPackage.GetTaggedValue(TaggedValues.<#= metaTaggedValue.Name #>).<#= metaTaggedValue.Cardinality == MetaCardinality.Many ? "SplitValues" : "Value" #>; }
        }
<#
		}
#>

        #endregion
	}
}