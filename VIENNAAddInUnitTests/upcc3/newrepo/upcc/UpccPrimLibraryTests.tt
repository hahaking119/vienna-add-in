<#@ template language="C#v3.5" hostspecific="True" debug="True" #>
<#@ output extension=".cs" #>
<#@ assembly name="Upcc.dll" #>
<#@ assembly name="VIENNAAddInUtils.dll" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Upcc"#>
<#@ import namespace="VIENNAAddInUtils.t4"#>
<#@ import namespace="VIENNAAddInUtils"#>
<# 
	var metaPackage = MetaModel.PrimLibrary;
	var extendManually = false;
#>
<# 
	var library = metaPackage.Name.FirstCharToLowerCase();
#>
using System.Collections.Generic;
using System.Linq;
using CctsRepository.<#= metaPackage.Name #>;
using Moq;
using NUnit.Framework;
using NUnit.Framework.SyntaxHelpers;
using VIENNAAddIn.upcc3.ccts.util;
using VIENNAAddInUnitTests.upcc3.newrepo.upcc.uml;

namespace VIENNAAddInUnitTests.upcc3.newrepo.upcc
{
    [TestFixture]
    public <#= extendManually ? "partial " : "" #>class Upcc<#= metaPackage.Name #>Tests
    {
        [Test]
        public void ShouldReturnId()
        {
            var umlPackage = new UmlPackageBuilder()
                .WithId(37)
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
            Assert.That(<#= library #>.Id, Is.EqualTo(umlPackage.Id));
        }

        [Test]
        public void ShouldReturnName()
        {
            var umlPackage = new UmlPackageBuilder()
                .WithName("aPackage")
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
            Assert.That(<#= library #>.Name, Is.EqualTo(umlPackage.Name));
        }
<# 
///==========================================================================================================================
/// Parent packages
///==========================================================================================================================

		foreach (var relation in MetaModel.GetParentPackageRelationsFor(metaPackage))
		{
#>

		[Test]
		public void ShouldResolve<#= relation.ParentPackageRole #>()
		{
            var parentUmlPackage = new UmlPackageBuilder()
                .WithId(76)
                .Build();
            var umlPackage = new UmlPackageBuilder()
				.WithParent(parentUmlPackage)
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
            Assert.That(<#= library #>.<#= relation.ParentPackageRole #>, Is.Not.Null);
            Assert.That(<#= library #>.<#= relation.ParentPackageRole #>.Id, Is.EqualTo(parentUmlPackage.Id));
		}
<#
		}

///==========================================================================================================================
/// Classifiers
///==========================================================================================================================

		foreach (var relation in MetaModel.GetClassifierRelationsFor(metaPackage))
		{
			var element = relation.ClassifierType.Stereotype;
			var classifier = relation.ClassifierType.Name.FirstCharToLowerCase();
			if (classifier == "enum") classifier = "@enum"; // dirty hack to avoid naming conflict with 'enum'
			var classifierType = relation.ClassifierType.GetType().Name.Substring(4);
#>

		[Test]
		public void ShouldResolve<#= relation.ClassifierRole #>()
		{
            var umlPackage = new UmlPackageBuilder()
                .With<#= classifierType #>(new Uml<#= classifierType #>Builder().WithId(57).Build())
                .With<#= classifierType #>(new Uml<#= classifierType #>Builder().WithId(61).Build())
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
            Assert.That(new List<int>(<#= library #>.<#= relation.ClassifierRole #>.Select(<#= classifier #> => <#= classifier #>.Id)),
						Is.EquivalentTo(new List<int>(umlPackage.<#= classifierType #>s.Select(<#= classifierType.FirstCharToLowerCase() #> => <#= classifierType.FirstCharToLowerCase() #>.Id))));
		}

		[Test]
		public void ShouldReturnEmptyEnumerationIfNo<#= relation.ClassifierRole #>Exist()
		{
            var umlPackage = new UmlPackageBuilder()
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
            Assert.That(<#= library #>.<#= relation.ClassifierRole #>, Is.Empty);
		}

		[Test]
		public void ShouldResolve<#= relation.ClassifierRole #>ByName()
		{
            var umlPackage = new UmlPackageBuilder()
                .With<#= classifierType #>(new Uml<#= classifierType #>Builder().WithId(57).WithName("prim57").Build())
                .With<#= classifierType #>(new Uml<#= classifierType #>Builder().WithId(61).WithName("prim61").Build())
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
            Assert.That(<#= library #>.Get<#= relation.ClassifierType.Name #>ByName("prim57").Id, Is.EqualTo(57));
		}

		[Test]
		public void ShouldReturnNullIf<#= relation.ClassifierRole #>CannotBeFoundByName()
		{
            var umlPackage = new UmlPackageBuilder()
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
            Assert.That(<#= library #>.Get<#= relation.ClassifierType.Name #>ByName("should not be found"), Is.Null);
		}

		[Test]
		public void ShouldCreate<#= relation.ClassifierRole #>AccordingToSpecification()
		{
            var equivalentPrim<#= classifierType #> = new Uml<#= classifierType #>Builder()
                .WithId(22)
                .WithName("prim22")
                .Build();
            var prim<#= classifierType #>Mock = new Uml<#= classifierType #>Builder()
                .WithId(23)
                .BuildMock();
            var umlPackageMock = new UmlPackageBuilder()
                .With<#= classifierType #>(equivalentPrim<#= classifierType #>)
                .BuildMock();
            umlPackageMock.Setup(umlPackage => umlPackage.Create<#= classifierType #>(It.IsAny<Uml<#= classifierType #>Spec>())).Returns(prim<#= classifierType #>Mock.Object);
            umlPackageMock.Setup(umlPackage => umlPackage.Get<#= classifierType #>ById(22)).Returns(equivalentPrim<#= classifierType #>);

            IPrimLibrary primLibrary = new UpccPrimLibrary(umlPackageMock.Object);
            var equivalentPrim = primLibrary.GetPrimByName("prim22");
            var primSpec = new PrimSpec
                           {
                               Name = "prim23",
                               IsEquivalentTo = equivalentPrim,
<#
			foreach (var metaTaggedValue in relation.ClassifierType.TaggedValues)
			{
				if (metaTaggedValue.Cardinality == MetaCardinality.Many)
				{
#>
            				   <#= metaTaggedValue.AsPropertyName() #> = new[] {"<#= metaTaggedValue.Name #>_Value1", "<#= metaTaggedValue.Name #>_Value2"},
<#
				}
				else
				{
#>
            				   <#= metaTaggedValue.AsPropertyName() #> = "<#= metaTaggedValue.Name #>_Value",
<#
				}
			}
#>
                           };
            var prim = primLibrary.CreatePrim(primSpec);
            Assert.That(prim.Id, Is.EqualTo(prim<#= classifierType #>Mock.Object.Id));
            umlPackageMock.Verify(umlPackage => umlPackage.Create<#= classifierType #>(new Uml<#= classifierType #>Spec
                                                                          {
                                                                              Name = primSpec.Name,
                                                                              TaggedValues = new[]
                                                                                             {
<#
			foreach (var metaTaggedValue in relation.ClassifierType.TaggedValues)
			{
#>
                                                                                                 new UmlTaggedValueSpec
                                                                                                 {
                                                                                                     Name = TaggedValues.<#= metaTaggedValue.Name #>.ToString(),
<#
				if (metaTaggedValue.Cardinality == MetaCardinality.Many)
				{
#>
                                                                                                     Value = MultiPartTaggedValue.Merge(new[] {"<#= metaTaggedValue.Name #>_Value1", "<#= metaTaggedValue.Name #>_Value2"}),
<#
				}
				else
				{
#>
                                                                                                     Value = "<#= metaTaggedValue.Name #>_Value",
<#
				}
#>
                                                                                                 },
<#
			}
#>
                                                                                             },
                                                                          }), Times.Exactly(1));
            prim<#= classifierType #>Mock.Verify(<#= classifierType.FirstCharToLowerCase() #> => <#= classifierType.FirstCharToLowerCase() #>
				.CreateDependency(new UmlDependencySpec<IUml<#= classifierType #>>
                                                                          {
                                                                              Stereotype = Stereotype.isEquivalentTo,
                                                                              Target = equivalentPrim<#= classifierType #>,
                                                                              LowerBound = "0",
                                                                              UpperBound = "1",
                                                                          }));
		}

		[Test]
		public void ShouldAutoGenerateUnspecified<#= relation.ClassifierType.Name #>TaggedValuesOnCreation()
		{
            Assert.Fail("not implemented");
		}

		[Test]
		public void ShouldUpdate<#= relation.ClassifierRole #>AccordingToSpecification()
		{
            Assert.Fail("not implemented");
		}

		[Test]
		public void ShouldAutoGenerateUnspecified<#= relation.ClassifierType.Name #>TaggedValuesOnUpdate()
		{
            Assert.Fail("not implemented");
		}

		[Test]
		public void ShouldNotAutoGenerateUnspecified<#= relation.ClassifierType.Name #>TaggedValuesOnUpdateIfAlreadySet()
		{
            Assert.Fail("not implemented");
		}

		[Test]
		public void ShouldRemove<#= relation.ClassifierRole #>()
		{
            Assert.Fail("not implemented");
		}

<#
		}
		
///==========================================================================================================================
/// Tagged Values
///==========================================================================================================================

#>

		[Test]
        public void ShouldReturnEmptyValuesForNullTaggedValues()
        {
            var umlPackage = new UmlPackageBuilder().Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
<#
	foreach (var metaTaggedValue in metaPackage.TaggedValues)
	{
#>
            Assert.That(<#= library #>.<#= metaTaggedValue.AsPropertyName() #>, Is.Not.Null);
            Assert.That(<#= library #>.<#= metaTaggedValue.AsPropertyName() #>, Is.Empty);
<#
	}
#>
        }

        [Test]
        public void ShouldReturnValueOfTaggedValues()
        {
            var umlPackage = new UmlPackageBuilder()
<#
	foreach (var metaTaggedValue in metaPackage.TaggedValues)
	{
		if (metaTaggedValue.Cardinality == MetaCardinality.Many)
		{
#>
                .WithMultiValuedTaggedValue(TaggedValues.<#= metaTaggedValue.Name #>, "<#= metaTaggedValue.Name #>_Value1", "<#= metaTaggedValue.Name #>_Value2")
<#
		}
		else
		{
#>
                .WithTaggedValue(TaggedValues.<#= metaTaggedValue.Name #>, "<#= metaTaggedValue.Name #>_Value")
<#
		}
	}
#>
                .Build();
            I<#= metaPackage.Name #> <#= library #> = new Upcc<#= metaPackage.Name #>(umlPackage);
<#
	foreach (var metaTaggedValue in metaPackage.TaggedValues)
	{
#>
<#
		if (metaTaggedValue.Cardinality == MetaCardinality.Many)
		{
#>
            Assert.That(<#= library #>.<#= metaTaggedValue.AsPropertyName() #>, Is.EquivalentTo(new[] {"<#= metaTaggedValue.Name #>_Value1", "<#= metaTaggedValue.Name #>_Value2"}));
<#
		}
		else
		{
#>
            Assert.That(<#= library #>.<#= metaTaggedValue.AsPropertyName() #>, Is.EqualTo("<#= metaTaggedValue.Name #>_Value"));
<#
		}
	}
#>
        }
	}
}
